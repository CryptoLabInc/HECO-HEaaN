<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AST Optimizer for FHE: Methods for handling children</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AST Optimizer for FHE
   </div>
   <div id="projectbrief">An optimizer for FHE-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Methods for handling children</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga680a94e1a61857e94177a79e5d8588ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga680a94e1a61857e94177a79e5d8588ab">AbstractNode::getMaxNumberChildren</a> ()</td></tr>
<tr class="separator:ga680a94e1a61857e94177a79e5d8588ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ad6064145b23d0db6cda7a254d1816"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga86ad6064145b23d0db6cda7a254d1816">AbstractNode::getChildren</a> () const</td></tr>
<tr class="separator:ga86ad6064145b23d0db6cda7a254d1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067cfe2f95324c36cfe3c8ad49d910c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga067cfe2f95324c36cfe3c8ad49d910c3">AbstractNode::getChildrenNonNull</a> () const</td></tr>
<tr class="separator:ga067cfe2f95324c36cfe3c8ad49d910c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0fc647d80e0a0638dc5212475ff1d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga3a0fc647d80e0a0638dc5212475ff1d1">AbstractNode::getDescendants</a> ()</td></tr>
<tr class="separator:ga3a0fc647d80e0a0638dc5212475ff1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3455077d7c2f5fe876736bc530ef14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gaee3455077d7c2f5fe876736bc530ef14">AbstractNode::addChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *child, bool addBackReference=true)</td></tr>
<tr class="separator:gaee3455077d7c2f5fe876736bc530ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823a5670ee7b3b8d31bc8b89f912ae17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga823a5670ee7b3b8d31bc8b89f912ae17">AbstractNode::addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference=true)</td></tr>
<tr class="separator:ga823a5670ee7b3b8d31bc8b89f912ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f2ad9e5498aa36ec2fe2ea233916e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga11f2ad9e5498aa36ec2fe2ea233916e1">AbstractNode::addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference, std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;::const_iterator insertPosition)</td></tr>
<tr class="separator:ga11f2ad9e5498aa36ec2fe2ea233916e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4417c5c9ab73b36f0131bbb8a77e9a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga4417c5c9ab73b36f0131bbb8a77e9a1a">AbstractNode::addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference, <a class="el" href="class_abstract_node.html">AbstractNode</a> *insertBeforeNode)</td></tr>
<tr class="separator:ga4417c5c9ab73b36f0131bbb8a77e9a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbb1dbb67989121ad80e9a31d013832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga5bbb1dbb67989121ad80e9a31d013832">AbstractNode::removeChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *child, bool removeBackreference=true)</td></tr>
<tr class="separator:ga5bbb1dbb67989121ad80e9a31d013832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e132143550927544b1f66c5fc1b822"><td class="memItemLeft" align="right" valign="top"><a id="ga38e132143550927544b1f66c5fc1b822"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga38e132143550927544b1f66c5fc1b822">AbstractNode::removeChildren</a> ()</td></tr>
<tr class="memdesc:ga38e132143550927544b1f66c5fc1b822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children from this node. Note: Does not update the child's parent. <br /></td></tr>
<tr class="separator:ga38e132143550927544b1f66c5fc1b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0701ca5077f4c8e72bb23f47847cd32f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga0701ca5077f4c8e72bb23f47847cd32f">AbstractNode::replaceChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *originalChild, <a class="el" href="class_abstract_node.html">AbstractNode</a> *newChild)</td></tr>
<tr class="separator:ga0701ca5077f4c8e72bb23f47847cd32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c88c4188fe630a98fae969655cba5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gae0c88c4188fe630a98fae969655cba5f">AbstractNode::replaceChildren</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *originalChild, std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; newChildren)</td></tr>
<tr class="separator:gae0c88c4188fe630a98fae969655cba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f882f7d81802944993122b2b0284a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gae9f882f7d81802944993122b2b0284a5">AbstractNode::countChildrenNonNull</a> () const</td></tr>
<tr class="separator:gae9f882f7d81802944993122b2b0284a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc240879d8ea5f8a17f2c6ad75d3a9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gacc240879d8ea5f8a17f2c6ad75d3a9dd">AbstractNode::getChildAtIndex</a> (int idx) const</td></tr>
<tr class="separator:gacc240879d8ea5f8a17f2c6ad75d3a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac253d38475ffb2b9314cf2b7f1a4f9e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gac253d38475ffb2b9314cf2b7f1a4f9e4">AbstractNode::getChildAtIndex</a> (int idx, bool isEdgeDirectionAware) const</td></tr>
<tr class="separator:gac253d38475ffb2b9314cf2b7f1a4f9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae475feb918ba7baa8ab48b08c3e0c45"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gaae475feb918ba7baa8ab48b08c3e0c45">AbstractNode::getParents</a> () const</td></tr>
<tr class="separator:gaae475feb918ba7baa8ab48b08c3e0c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1b017cb18e69edb9e3fb4a83065ca9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga1b1b017cb18e69edb9e3fb4a83065ca9">AbstractNode::getParentsNonNull</a> () const</td></tr>
<tr class="separator:ga1b1b017cb18e69edb9e3fb4a83065ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ae438cb3ceceb4cb76105e44f5c7e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gab9ae438cb3ceceb4cb76105e44f5c7e4">AbstractNode::getAncestors</a> ()</td></tr>
<tr class="separator:gab9ae438cb3ceceb4cb76105e44f5c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84feb2d0b8fe0cd9ec70039a6147cc05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga84feb2d0b8fe0cd9ec70039a6147cc05">AbstractNode::addParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentToAdd, bool addBackreference=true)</td></tr>
<tr class="separator:ga84feb2d0b8fe0cd9ec70039a6147cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda8df2202074840856b30041648319d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gafda8df2202074840856b30041648319d">AbstractNode::removeParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentToBeRemoved, bool removeBackreference=true)</td></tr>
<tr class="separator:gafda8df2202074840856b30041648319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bfef862849ba2a11873ee120364e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga50bfef862849ba2a11873ee120364e09">AbstractNode::removeFromParents</a> (bool removeParentBackreference=true)</td></tr>
<tr class="separator:ga50bfef862849ba2a11873ee120364e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f1af895f45e9031069ec361ceb6499"><td class="memItemLeft" align="right" valign="top"><a id="ga51f1af895f45e9031069ec361ceb6499"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga51f1af895f45e9031069ec361ceb6499">AbstractNode::removeParents</a> ()</td></tr>
<tr class="memdesc:ga51f1af895f45e9031069ec361ceb6499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all parents from this node. Note: Does not update the parent's children. <br /></td></tr>
<tr class="separator:ga51f1af895f45e9031069ec361ceb6499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58926eb9237736d0a3593bd96375754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gac58926eb9237736d0a3593bd96375754">AbstractNode::hasParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentNode)</td></tr>
<tr class="separator:gac58926eb9237736d0a3593bd96375754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7d6aa6042b9935b178696c95840906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga3d7d6aa6042b9935b178696c95840906">AbstractNode::getOnlyParent</a> ()</td></tr>
<tr class="separator:ga3d7d6aa6042b9935b178696c95840906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaee3455077d7c2f5fe876736bc530ef14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3455077d7c2f5fe876736bc530ef14">&#9670;&nbsp;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addBackReference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new child node to the node's list of children. <a class="el" href="class_if.html">If</a> addBackReference is True then also updates the child's list of parent nodes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The node to be added as child. </td></tr>
    <tr><td class="paramname">addBackReference</td><td><a class="el" href="class_if.html">If</a> True, then adds this node as parent to the child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4417c5c9ab73b36f0131bbb8a77e9a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4417c5c9ab73b36f0131bbb8a77e9a1a">&#9670;&nbsp;</a></span>addChildren() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::addChildren </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>childrenToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addBackReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>insertBeforeNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds multiple children to the node's list of children at the position (or more precisely, before) indicated by the passed node of the children vector. <a class="el" href="class_if.html">If</a> addBackReference is True then also updates the child's list of parent nodes for each of the added children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childrenToAdd</td><td>A vector of nodes to be added as children to this node. </td></tr>
    <tr><td class="paramname">addBackReference</td><td><a class="el" href="class_if.html">If</a> True, then adds this node as parent to each of the child nodes. </td></tr>
    <tr><td class="paramname">insertBeforeNode</td><td>The node (must be a children of this node) that is used to determine the insert position of the children to be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the given node (insertBeforeNode) could not be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11f2ad9e5498aa36ec2fe2ea233916e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11f2ad9e5498aa36ec2fe2ea233916e1">&#9670;&nbsp;</a></span>addChildren() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::addChildren </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>childrenToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addBackReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>insertPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds multiple children to the node's list of children at the position (or more precisely, before) indicated by the passed insertPosition iterator of the children vector. <a class="el" href="class_if.html">If</a> addBackReference is True then also updates the child's list of parent nodes for each of the added children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childrenToAdd</td><td>A vector of nodes to be added as children to this node. </td></tr>
    <tr><td class="paramname">addBackReference</td><td><a class="el" href="class_if.html">If</a> True, then adds this node as parent to each of the child nodes. </td></tr>
    <tr><td class="paramname">insertPosition</td><td>The position before which the new nodes should be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga823a5670ee7b3b8d31bc8b89f912ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga823a5670ee7b3b8d31bc8b89f912ae17">&#9670;&nbsp;</a></span>addChildren() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::addChildren </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>childrenToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addBackReference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds multiple children to the node's list of children. <a class="el" href="class_if.html">If</a> addBackReference is True then also updates the child's list of parent nodes for each of the added children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childrenToAdd</td><td>A vector of nodes to be added as children to this node. </td></tr>
    <tr><td class="paramname">addBackReference</td><td><a class="el" href="class_if.html">If</a> True, then adds this node as parent to each of the child nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84feb2d0b8fe0cd9ec70039a6147cc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84feb2d0b8fe0cd9ec70039a6147cc05">&#9670;&nbsp;</a></span>addParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::addParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>parentToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addBackreference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new parent to this node's list of parents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentToAdd</td><td>The parent node to be added. </td></tr>
    <tr><td class="paramname">addBackreference</td><td><a class="el" href="class_if.html">If</a> True, then also adds this node as child to the new parent node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9f882f7d81802944993122b2b0284a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f882f7d81802944993122b2b0284a5">&#9670;&nbsp;</a></span>countChildrenNonNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractNode::countChildrenNonNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of children nodes that are not null (nullptr). </p><dl class="section return"><dt>Returns</dt><dd>An integer indicating the number of non-nullptr children nodes. </dd></dl>

</div>
</div>
<a id="gab9ae438cb3ceceb4cb76105e44f5c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9ae438cb3ceceb4cb76105e44f5c7e4">&#9670;&nbsp;</a></span>getAncestors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; AbstractNode::getAncestors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all the ancestor nodes of the current node, i.e., the ancestors of this node, the ancestors of the ancestors et cetera. </p><dl class="section return"><dt>Returns</dt><dd>A list of ancestor nodes. </dd></dl>

</div>
</div>
<a id="gacc240879d8ea5f8a17f2c6ad75d3a9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc240879d8ea5f8a17f2c6ad75d3a9dd">&#9670;&nbsp;</a></span>getChildAtIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * AbstractNode::getChildAtIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The position of the children in the <a class="el" href="class_abstract_node.html#a71a667554f9ca17ad0d56cbe5b22cc7f" title="Stores the children nodes of the current node.">AbstractNode::children</a> vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The child at the given index of the children vector, or a nullptr if there is no child at this position. </dd></dl>

</div>
</div>
<a id="gac253d38475ffb2b9314cf2b7f1a4f9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac253d38475ffb2b9314cf2b7f1a4f9e4">&#9670;&nbsp;</a></span>getChildAtIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * AbstractNode::getChildAtIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEdgeDirectionAware</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This special variant of getChildAtIndex returns the n-th parent instead of n-th child if isEdgeDirectionAware is passed and is true, and the current node has the property isReversed set to True. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The position of the child to be retrieved. </td></tr>
    <tr><td class="paramname">isEdgeDirectionAware</td><td><a class="el" href="class_if.html">If</a> the node's status of isReversed should be considered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the node at the specified index in the children or parent vector. </dd></dl>

</div>
</div>
<a id="ga86ad6064145b23d0db6cda7a254d1816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ad6064145b23d0db6cda7a254d1816">&#9670;&nbsp;</a></span>getChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp; AbstractNode::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the vector of children nodes. </p><dl class="section return"><dt>Returns</dt><dd>A reference to the vector of this node's children. </dd></dl>

</div>
</div>
<a id="ga067cfe2f95324c36cfe3c8ad49d910c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067cfe2f95324c36cfe3c8ad49d910c3">&#9670;&nbsp;</a></span>getChildrenNonNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; AbstractNode::getChildrenNonNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of pointers to children nodes but without those children that are nullptr. </p><dl class="section return"><dt>Returns</dt><dd>A vector of non-nullptr children. </dd></dl>

</div>
</div>
<a id="ga3a0fc647d80e0a0638dc5212475ff1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a0fc647d80e0a0638dc5212475ff1d1">&#9670;&nbsp;</a></span>getDescendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; AbstractNode::getDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all the descendants nodes of the current node, i.e., the children of the children and the children of their children et cetera. </p><dl class="section return"><dt>Returns</dt><dd>A list of descendant nodes. </dd></dl>

</div>
</div>
<a id="ga680a94e1a61857e94177a79e5d8588ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680a94e1a61857e94177a79e5d8588ab">&#9670;&nbsp;</a></span>getMaxNumberChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractNode::getMaxNumberChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates the number of children that are allowed for a specific node. <a class="el" href="class_for.html">For</a> example, a arithmetic expression accepts exactly three attributes and hence also exactly three children: left operand, right operand, and operator. <a class="el" href="class_if.html">If</a> the node does not implement support for child/parent relationships, <a class="el" href="group__parents.html#ga680a94e1a61857e94177a79e5d8588ab">getMaxNumberChildren()</a> return 0. </p><dl class="section return"><dt>Returns</dt><dd>An integer indicating the number of allowed children for a specific node. </dd></dl>

<p>Reimplemented in <a class="el" href="class_matrix.html#aad64645935e83c12ccc6c5ab6356799b">Matrix&lt; T &gt;</a>, <a class="el" href="class_var_decl.html#a85b3beede024be269e838dd59d7048c4">VarDecl</a>, <a class="el" href="class_function.html#a63d68e9b2b23b123d3fe3b13bea2abf4">Function</a>, <a class="el" href="class_var_assignm.html#a0b277c03e0c6ea841f518196df932979">VarAssignm</a>, <a class="el" href="class_return.html#a9909ac70f65299e43fd539f7421946ea">Return</a>, <a class="el" href="class_unary_expr.html#afd8eca2716eea050d27fa88aaf1b3c28">UnaryExpr</a>, <a class="el" href="class_for.html#aefa82931cfb8a8f65a410cf40d5cc5b2">For</a>, <a class="el" href="class_matrix_element_ref.html#aa2299ff8c6829be40ce038e4d365b0c1">MatrixElementRef</a>, <a class="el" href="class_call.html#af1208c8bce54b77e6cd96f0c670fb006">Call</a>, <a class="el" href="class_get_matrix_size.html#a57d6d55759054f561a4f9003880c6bb0">GetMatrixSize</a>, <a class="el" href="class_block.html#a676784c7009b472921f6480ac5c87e53">Block</a>, <a class="el" href="class_function_parameter.html#a771297240b13c61c8301a74ff6020e53">FunctionParameter</a>, <a class="el" href="class_if.html#af6961afb9692aaeeb551ebd5e48763c6">If</a>, <a class="el" href="class_transpose.html#a58b225cd13307e6d2c8f8aa3bb605e50">Transpose</a>, <a class="el" href="class_while.html#a762228f25805bb25193ffa7acfd63571">While</a>, <a class="el" href="class_operator_expr.html#a3f6a361ca69eae2ba9ca38540790d505">OperatorExpr</a>, <a class="el" href="class_rotate.html#a20f3d6d52c55098e08d682631aad4386">Rotate</a>, <a class="el" href="class_parameter_list.html#af22158ec28263ca2e62054d49ff41d29">ParameterList</a>, <a class="el" href="class_matrix_assignm.html#a5e88f81e7dc657bf3e1131d164782dab">MatrixAssignm</a>, and <a class="el" href="class_abstract_binary_expr.html#a597b7d18a6dbd4a2d76245873ff90627">AbstractBinaryExpr</a>.</p>

</div>
</div>
<a id="ga3d7d6aa6042b9935b178696c95840906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d7d6aa6042b9935b178696c95840906">&#9670;&nbsp;</a></span>getOnlyParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * AbstractNode::getOnlyParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the only parent node. <a class="el" href="class_if.html">If</a> this node has more than one parent, then a std::logic_exception is thrown. </p><dl class="section return"><dt>Returns</dt><dd>A pointer to the node's only parent node. </dd></dl>

</div>
</div>
<a id="gaae475feb918ba7baa8ab48b08c3e0c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae475feb918ba7baa8ab48b08c3e0c45">&#9670;&nbsp;</a></span>getParents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp; AbstractNode::getParents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the vector of parent nodes. </p><dl class="section return"><dt>Returns</dt><dd>A reference to the vector of this node's parents. </dd></dl>

</div>
</div>
<a id="ga1b1b017cb18e69edb9e3fb4a83065ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b1b017cb18e69edb9e3fb4a83065ca9">&#9670;&nbsp;</a></span>getParentsNonNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; AbstractNode::getParentsNonNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of pointers to parent nodes but without those parents that are nullptr. </p><dl class="section return"><dt>Returns</dt><dd>A vector of non-nullptr parent nodes. </dd></dl>

</div>
</div>
<a id="gac58926eb9237736d0a3593bd96375754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58926eb9237736d0a3593bd96375754">&#9670;&nbsp;</a></span>hasParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractNode::hasParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>parentNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether this node has a certain parent (parentNode). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentNode</td><td>The node that is searched for in this node's parent list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this node has the given parentNode as parent, otherwise returns False. </dd></dl>

</div>
</div>
<a id="ga5bbb1dbb67989121ad80e9a31d013832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bbb1dbb67989121ad80e9a31d013832">&#9670;&nbsp;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeBackreference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the given child from the list of children. <a class="el" href="class_if.html">If</a> <a class="el" href="group__parents.html#ga680a94e1a61857e94177a79e5d8588ab">getMaxNumberChildren()</a> returns -1 (i.e., this node supports an inifinite number of children, then the respective child is simply deleted. In any other case, the child node is overwritten by -1 such that the order of other children is preserved. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child to be removed from this node's children. </td></tr>
    <tr><td class="paramname">removeBackreference</td><td><a class="el" href="class_if.html">If</a> True, then also removes this node from the children's list of parent nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50bfef862849ba2a11873ee120364e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50bfef862849ba2a11873ee120364e09">&#9670;&nbsp;</a></span>removeFromParents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * AbstractNode::removeFromParents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeParentBackreference</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes this node from its parent's children list. <a class="el" href="class_if.html">If</a> removeParentBackreference is True, then also removes the parents from this node's parent list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">removeParentBackreference</td><td>Indicates whether to update this node's parents list too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafda8df2202074840856b30041648319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda8df2202074840856b30041648319d">&#9670;&nbsp;</a></span>removeParent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::removeParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>parentToBeRemoved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeBackreference</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a certain parent from this node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentToBeRemoved</td><td>The node to be removed from this node's parents. </td></tr>
    <tr><td class="paramname">removeBackreference</td><td><a class="el" href="class_if.html">If</a> True, then also removes this node from the parentToBeRemoved node's children list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0701ca5077f4c8e72bb23f47847cd32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0701ca5077f4c8e72bb23f47847cd32f">&#9670;&nbsp;</a></span>replaceChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::replaceChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>originalChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>newChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces a given child (originalChild) of this node by a new node (newChild) and updates the child and parent references of both nodes. This method preserves the order of the children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalChild</td><td>The node to be replaced by newChild. </td></tr>
    <tr><td class="paramname">newChild</td><td>The node to be added at the same position as the original child was. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_matrix.html#a477ed2fcc4b7915061f916d12393e01e">Matrix&lt; T &gt;</a>, <a class="el" href="class_operator_expr.html#a762db37a274570b76006bb3fd5edfaee">OperatorExpr</a>, and <a class="el" href="class_matrix.html#a171d7f0eb34c6643f6248095dd9c244a">Matrix&lt; T &gt;</a>.</p>

</div>
</div>
<a id="gae0c88c4188fe630a98fae969655cba5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0c88c4188fe630a98fae969655cba5f">&#9670;&nbsp;</a></span>replaceChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::replaceChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>originalChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td>
          <td class="paramname"><em>newChildren</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces a given child (originalChild) of this node by one or multiple new nodes (newChildren) and updates the child and parent references of all affected nodes. This method preserves the order of the children when inserting the nodes. <a class="el" href="class_for.html">For</a> example: replaceChildren(C, [X, V, W]) on node with children = [a b C d e f] results in children = [a b X V W d e f]. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalChild</td><td>The node to be replaced by newChildren. </td></tr>
    <tr><td class="paramname">newChildren</td><td>The children to be added at the originalChild's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
