<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AST Optimizer for FHE: AbstractNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AST Optimizer for FHE
   </div>
   <div id="projectbrief">An optimizer for FHE-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="class_abstract_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AbstractNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for AbstractNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_abstract_node.png" usemap="#AbstractNode_map" alt=""/>
  <map id="AbstractNode_map" name="AbstractNode_map">
<area href="class_abstract_expr.html" alt="AbstractExpr" shape="rect" coords="0,56,122,80"/>
<area href="class_abstract_matrix.html" alt="AbstractMatrix" shape="rect" coords="264,56,386,80"/>
<area href="class_abstract_statement.html" alt="AbstractStatement" shape="rect" coords="396,56,518,80"/>
<area href="class_datatype.html" alt="Datatype" shape="rect" coords="528,56,650,80"/>
<area href="class_operator.html" alt="Operator" shape="rect" coords="660,56,782,80"/>
<area href="class_abstract_binary_expr.html" alt="AbstractBinaryExpr" shape="rect" coords="132,112,254,136"/>
<area href="class_abstract_literal.html" alt="AbstractLiteral" shape="rect" coords="132,168,254,192"/>
<area href="class_call.html" alt="Call" shape="rect" coords="132,224,254,248"/>
<area href="class_call_external.html" alt="CallExternal" shape="rect" coords="132,280,254,304"/>
<area href="class_function_parameter.html" alt="FunctionParameter" shape="rect" coords="132,336,254,360"/>
<area href="class_get_matrix_size.html" alt="GetMatrixSize" shape="rect" coords="132,392,254,416"/>
<area href="class_matrix_element_ref.html" alt="MatrixElementRef" shape="rect" coords="132,448,254,472"/>
<area href="class_operator_expr.html" alt="OperatorExpr" shape="rect" coords="132,504,254,528"/>
<area href="class_rotate.html" alt="Rotate" shape="rect" coords="132,560,254,584"/>
<area href="class_transpose.html" alt="Transpose" shape="rect" coords="132,616,254,640"/>
<area href="class_unary_expr.html" alt="UnaryExpr" shape="rect" coords="132,672,254,696"/>
<area href="class_variable.html" alt="Variable" shape="rect" coords="132,728,254,752"/>
<area href="class_matrix.html" alt="Matrix&lt; T &gt;" shape="rect" coords="264,112,386,136"/>
<area href="class_block.html" alt="Block" shape="rect" coords="528,112,650,136"/>
<area href="class_for.html" alt="For" shape="rect" coords="528,168,650,192"/>
<area href="class_function.html" title="Function has two children: First, a ParameterList and then a Block with the actual function Body." alt="Function" shape="rect" coords="528,224,650,248"/>
<area href="class_if.html" alt="If" shape="rect" coords="528,280,650,304"/>
<area href="class_matrix_assignm.html" alt="MatrixAssignm" shape="rect" coords="528,336,650,360"/>
<area href="class_parameter_list.html" alt="ParameterList" shape="rect" coords="528,392,650,416"/>
<area href="class_return.html" alt="Return" shape="rect" coords="528,448,650,472"/>
<area href="class_var_assignm.html" alt="VarAssignm" shape="rect" coords="528,504,650,528"/>
<area href="class_var_decl.html" alt="VarDecl" shape="rect" coords="528,560,650,584"/>
<area href="class_while.html" alt="While" shape="rect" coords="528,616,650,640"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e4c9b9841c8b860e450b8eb089f9b85"><td class="memItemLeft" align="right" valign="top"><a id="a3e4c9b9841c8b860e450b8eb089f9b85"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a3e4c9b9841c8b860e450b8eb089f9b85">~AbstractNode</a> ()=0</td></tr>
<tr class="memdesc:a3e4c9b9841c8b860e450b8eb089f9b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Destructor, force class to be abstract. <br /></td></tr>
<tr class="separator:a3e4c9b9841c8b860e450b8eb089f9b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc40127801e7777c8094f17a3b1efcb"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a8cc40127801e7777c8094f17a3b1efcb">getNodeType</a> () const =0</td></tr>
<tr class="separator:a8cc40127801e7777c8094f17a3b1efcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5441e6f42332beaa1291139986f800"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a8c5441e6f42332beaa1291139986f800">getUniqueNodeId</a> ()</td></tr>
<tr class="separator:a8c5441e6f42332beaa1291139986f800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680a94e1a61857e94177a79e5d8588ab"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga680a94e1a61857e94177a79e5d8588ab">getMaxNumberChildren</a> ()</td></tr>
<tr class="separator:ga680a94e1a61857e94177a79e5d8588ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ad6064145b23d0db6cda7a254d1816"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga86ad6064145b23d0db6cda7a254d1816">getChildren</a> () const</td></tr>
<tr class="separator:ga86ad6064145b23d0db6cda7a254d1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067cfe2f95324c36cfe3c8ad49d910c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga067cfe2f95324c36cfe3c8ad49d910c3">getChildrenNonNull</a> () const</td></tr>
<tr class="separator:ga067cfe2f95324c36cfe3c8ad49d910c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0fc647d80e0a0638dc5212475ff1d1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga3a0fc647d80e0a0638dc5212475ff1d1">getDescendants</a> ()</td></tr>
<tr class="separator:ga3a0fc647d80e0a0638dc5212475ff1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3455077d7c2f5fe876736bc530ef14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gaee3455077d7c2f5fe876736bc530ef14">addChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *child, bool addBackReference=true)</td></tr>
<tr class="separator:gaee3455077d7c2f5fe876736bc530ef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga823a5670ee7b3b8d31bc8b89f912ae17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga823a5670ee7b3b8d31bc8b89f912ae17">addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference=true)</td></tr>
<tr class="separator:ga823a5670ee7b3b8d31bc8b89f912ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11f2ad9e5498aa36ec2fe2ea233916e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga11f2ad9e5498aa36ec2fe2ea233916e1">addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference, std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;::const_iterator insertPosition)</td></tr>
<tr class="separator:ga11f2ad9e5498aa36ec2fe2ea233916e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4417c5c9ab73b36f0131bbb8a77e9a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga4417c5c9ab73b36f0131bbb8a77e9a1a">addChildren</a> (const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;childrenToAdd, bool addBackReference, <a class="el" href="class_abstract_node.html">AbstractNode</a> *insertBeforeNode)</td></tr>
<tr class="separator:ga4417c5c9ab73b36f0131bbb8a77e9a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbb1dbb67989121ad80e9a31d013832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga5bbb1dbb67989121ad80e9a31d013832">removeChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *child, bool removeBackreference=true)</td></tr>
<tr class="separator:ga5bbb1dbb67989121ad80e9a31d013832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38e132143550927544b1f66c5fc1b822"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga38e132143550927544b1f66c5fc1b822">removeChildren</a> ()</td></tr>
<tr class="memdesc:ga38e132143550927544b1f66c5fc1b822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children from this node. Note: Does not update the child's parent. <br /></td></tr>
<tr class="separator:ga38e132143550927544b1f66c5fc1b822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0701ca5077f4c8e72bb23f47847cd32f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga0701ca5077f4c8e72bb23f47847cd32f">replaceChild</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *originalChild, <a class="el" href="class_abstract_node.html">AbstractNode</a> *newChild)</td></tr>
<tr class="separator:ga0701ca5077f4c8e72bb23f47847cd32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c88c4188fe630a98fae969655cba5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gae0c88c4188fe630a98fae969655cba5f">replaceChildren</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *originalChild, std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; newChildren)</td></tr>
<tr class="separator:gae0c88c4188fe630a98fae969655cba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f882f7d81802944993122b2b0284a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gae9f882f7d81802944993122b2b0284a5">countChildrenNonNull</a> () const</td></tr>
<tr class="separator:gae9f882f7d81802944993122b2b0284a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc240879d8ea5f8a17f2c6ad75d3a9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gacc240879d8ea5f8a17f2c6ad75d3a9dd">getChildAtIndex</a> (int idx) const</td></tr>
<tr class="separator:gacc240879d8ea5f8a17f2c6ad75d3a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac253d38475ffb2b9314cf2b7f1a4f9e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gac253d38475ffb2b9314cf2b7f1a4f9e4">getChildAtIndex</a> (int idx, bool isEdgeDirectionAware) const</td></tr>
<tr class="separator:gac253d38475ffb2b9314cf2b7f1a4f9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae475feb918ba7baa8ab48b08c3e0c45"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gaae475feb918ba7baa8ab48b08c3e0c45">getParents</a> () const</td></tr>
<tr class="separator:gaae475feb918ba7baa8ab48b08c3e0c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b1b017cb18e69edb9e3fb4a83065ca9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga1b1b017cb18e69edb9e3fb4a83065ca9">getParentsNonNull</a> () const</td></tr>
<tr class="separator:ga1b1b017cb18e69edb9e3fb4a83065ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ae438cb3ceceb4cb76105e44f5c7e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gab9ae438cb3ceceb4cb76105e44f5c7e4">getAncestors</a> ()</td></tr>
<tr class="separator:gab9ae438cb3ceceb4cb76105e44f5c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84feb2d0b8fe0cd9ec70039a6147cc05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga84feb2d0b8fe0cd9ec70039a6147cc05">addParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentToAdd, bool addBackreference=true)</td></tr>
<tr class="separator:ga84feb2d0b8fe0cd9ec70039a6147cc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda8df2202074840856b30041648319d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gafda8df2202074840856b30041648319d">removeParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentToBeRemoved, bool removeBackreference=true)</td></tr>
<tr class="separator:gafda8df2202074840856b30041648319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bfef862849ba2a11873ee120364e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga50bfef862849ba2a11873ee120364e09">removeFromParents</a> (bool removeParentBackreference=true)</td></tr>
<tr class="separator:ga50bfef862849ba2a11873ee120364e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f1af895f45e9031069ec361ceb6499"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga51f1af895f45e9031069ec361ceb6499">removeParents</a> ()</td></tr>
<tr class="memdesc:ga51f1af895f45e9031069ec361ceb6499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all parents from this node. Note: Does not update the parent's children. <br /></td></tr>
<tr class="separator:ga51f1af895f45e9031069ec361ceb6499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58926eb9237736d0a3593bd96375754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#gac58926eb9237736d0a3593bd96375754">hasParent</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *parentNode)</td></tr>
<tr class="separator:gac58926eb9237736d0a3593bd96375754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d7d6aa6042b9935b178696c95840906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__parents.html#ga3d7d6aa6042b9935b178696c95840906">getOnlyParent</a> ()</td></tr>
<tr class="separator:ga3d7d6aa6042b9935b178696c95840906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2479945fea5f323f14ac1a5f8615aad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a2479945fea5f323f14ac1a5f8615aad6">swapChildrenParents</a> ()</td></tr>
<tr class="separator:a2479945fea5f323f14ac1a5f8615aad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890a24af49cedda13f23cbe41931dee5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a890a24af49cedda13f23cbe41931dee5">accept</a> (<a class="el" href="class_visitor.html">Visitor</a> &amp;v)=0</td></tr>
<tr class="separator:a890a24af49cedda13f23cbe41931dee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee4c4915b6f76415aa2187535359899"><td class="memItemLeft" align="right" valign="top">virtual json&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a0ee4c4915b6f76415aa2187535359899">toJson</a> () const</td></tr>
<tr class="separator:a0ee4c4915b6f76415aa2187535359899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee58b60a470f2e494e0db1808c87b13d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#aee58b60a470f2e494e0db1808c87b13d">toString</a> (bool printChildren) const</td></tr>
<tr class="separator:aee58b60a470f2e494e0db1808c87b13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267513a1115e86df8966caf998e71e0e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a267513a1115e86df8966caf998e71e0e">cloneFlat</a> ()</td></tr>
<tr class="separator:a267513a1115e86df8966caf998e71e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f13808b586865a27e2635995be5056"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#ab7f13808b586865a27e2635995be5056">clone</a> (bool keepOriginalUniqueNodeId)=0</td></tr>
<tr class="separator:ab7f13808b586865a27e2635995be5056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeef4bb93c1788d6ebce8ab634d9045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a6eeef4bb93c1788d6ebce8ab634d9045">updateClone</a> (bool keepOriginalUniqueNodeId, <a class="el" href="class_abstract_node.html">AbstractNode</a> *originalNode)</td></tr>
<tr class="separator:a6eeef4bb93c1788d6ebce8ab634d9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad720dd5baeb746174fc08c8500cd2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#aad720dd5baeb746174fc08c8500cd2eb">setUniqueNodeId</a> (const std::string &amp;newUniqueNodeId)</td></tr>
<tr class="separator:aad720dd5baeb746174fc08c8500cd2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f2290759cb522619af77c630b6eba9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a76f2290759cb522619af77c630b6eba9">supportsCircuitMode</a> ()</td></tr>
<tr class="separator:a76f2290759cb522619af77c630b6eba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80a79af24ef63bb4602cd7abbb31dec"><td class="memItemLeft" align="right" valign="top"><a id="ab80a79af24ef63bb4602cd7abbb31dec"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#ab80a79af24ef63bb4602cd7abbb31dec">isolateNode</a> ()</td></tr>
<tr class="memdesc:ab80a79af24ef63bb4602cd7abbb31dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this node from all of its parents and children, and also removes all parents and children from this node. <br /></td></tr>
<tr class="separator:ab80a79af24ef63bb4602cd7abbb31dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3905c64474339cfcf742f982633364e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a3905c64474339cfcf742f982633364e9">hasReversedEdges</a> () const</td></tr>
<tr class="separator:a3905c64474339cfcf742f982633364e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1fab41e507f447fb47009a2bbfb403"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef1fab41e507f447fb47009a2bbfb403"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#aef1fab41e507f447fb47009a2bbfb403">castTo</a> ()</td></tr>
<tr class="separator:aef1fab41e507f447fb47009a2bbfb403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f200a84bf9e925ca39a6866a4d43588"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a3f200a84bf9e925ca39a6866a4d43588">generateOutputString</a> (bool printChildren, std::vector&lt; std::string &gt; attributes) const</td></tr>
<tr class="separator:a3f200a84bf9e925ca39a6866a4d43588"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0df7a9545812739bb59d122a51ba99c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#af0df7a9545812739bb59d122a51ba99c">resetNodeIdCounter</a> ()</td></tr>
<tr class="separator:af0df7a9545812739bb59d122a51ba99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a39c2f65b954b0ab15e8e30da84f68926"><td class="memItemLeft" align="right" valign="top"><a id="a39c2f65b954b0ab15e8e30da84f68926"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a39c2f65b954b0ab15e8e30da84f68926">isReversed</a> {false}</td></tr>
<tr class="memdesc:a39c2f65b954b0ab15e8e30da84f68926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the edges of this node are reversed compared to its initial state. <br /></td></tr>
<tr class="separator:a39c2f65b954b0ab15e8e30da84f68926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a53eabf948b80068841182ec9987db78b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a53eabf948b80068841182ec9987db78b">generateUniqueNodeId</a> ()</td></tr>
<tr class="separator:a53eabf948b80068841182ec9987db78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b59e2377b8841ec1762bbca9ba88d2d"><td class="memItemLeft" align="right" valign="top"><a id="a7b59e2377b8841ec1762bbca9ba88d2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a7b59e2377b8841ec1762bbca9ba88d2d">AbstractNode</a> ()</td></tr>
<tr class="memdesc:a7b59e2377b8841ec1762bbca9ba88d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor, defines some default behavior for subclasses related to IDs. <br /></td></tr>
<tr class="separator:a7b59e2377b8841ec1762bbca9ba88d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ad585516679d3c13dea9dbe86afbf6e6b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#ad585516679d3c13dea9dbe86afbf6e6b">getAndIncrementNodeId</a> ()</td></tr>
<tr class="separator:ad585516679d3c13dea9dbe86afbf6e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a864ad3a5c7ab4da0651ea1369965fe00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a864ad3a5c7ab4da0651ea1369965fe00">assignedNodeId</a> {-1}</td></tr>
<tr class="separator:a864ad3a5c7ab4da0651ea1369965fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a667554f9ca17ad0d56cbe5b22cc7f"><td class="memItemLeft" align="right" valign="top"><a id="a71a667554f9ca17ad0d56cbe5b22cc7f"></a>
std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a71a667554f9ca17ad0d56cbe5b22cc7f">children</a> {}</td></tr>
<tr class="memdesc:a71a667554f9ca17ad0d56cbe5b22cc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the children nodes of the current node. <br /></td></tr>
<tr class="separator:a71a667554f9ca17ad0d56cbe5b22cc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e34201f74ae8d2bd11ad016f82628f3"><td class="memItemLeft" align="right" valign="top"><a id="a0e34201f74ae8d2bd11ad016f82628f3"></a>
std::vector&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#a0e34201f74ae8d2bd11ad016f82628f3">parents</a> {}</td></tr>
<tr class="memdesc:a0e34201f74ae8d2bd11ad016f82628f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the parent nodes of the current node. <br /></td></tr>
<tr class="separator:a0e34201f74ae8d2bd11ad016f82628f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fde5c0e258f4603159f3dff359df0a"><td class="memItemLeft" align="right" valign="top"><a id="aa1fde5c0e258f4603159f3dff359df0a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#aa1fde5c0e258f4603159f3dff359df0a">uniqueNodeId</a></td></tr>
<tr class="memdesc:aa1fde5c0e258f4603159f3dff359df0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identifier that is unique among all nodes during runtime. <br /></td></tr>
<tr class="separator:aa1fde5c0e258f4603159f3dff359df0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ab3d626a24e6c737b61d4cd0aa0b36a43"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_node.html#ab3d626a24e6c737b61d4cd0aa0b36a43">nodeIdCounter</a> = 0</td></tr>
<tr class="separator:ab3d626a24e6c737b61d4cd0aa0b36a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a890a24af49cedda13f23cbe41931dee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890a24af49cedda13f23cbe41931dee5">&#9670;&nbsp;</a></span>accept()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void AbstractNode::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visitor.html">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Part of the visitor pattern. Must be overridden in derived classes and must call v.visit(node). This allows the correct overload for the derived class to be called in the visitor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><a class="el" href="class_visitor.html">Visitor</a> that offers a visit() method </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_matrix.html#a505d5e321442b5412f911d08d4da04e6">Matrix&lt; T &gt;</a>, <a class="el" href="class_datatype.html#aee110fa5c75961288fd4fb25658874a9">Datatype</a>, <a class="el" href="class_function.html#ad2f04201ce066c1cb7cfd8e782e7f67a">Function</a>, <a class="el" href="class_var_decl.html#a5d117b06478d4fce83ee722662f32424">VarDecl</a>, <a class="el" href="class_arithmetic_expr.html#afd297dc671f35b49d27436b0ee9858b4">ArithmeticExpr</a>, <a class="el" href="class_rotate.html#a6a5d7b2ba2d4ff9eb03e43d880646b4c">Rotate</a>, <a class="el" href="class_operator.html#a01c33b27ef4a52e9b50899f45b3a67d8">Operator</a>, <a class="el" href="class_literal_float.html#a8f8ad9f304b29732ed6a03e157b39ef2">LiteralFloat</a>, <a class="el" href="class_literal_string.html#a163fa2029352132b4ddb036e13489cdf">LiteralString</a>, <a class="el" href="class_get_matrix_size.html#aea0294fb646d1fc01933f8c8963a9a9e">GetMatrixSize</a>, <a class="el" href="class_literal_int.html#a4558b32f0f264ac5574132d443924e85">LiteralInt</a>, <a class="el" href="class_logical_expr.html#af73df795e7fd09592ffd3f445bf21e68">LogicalExpr</a>, <a class="el" href="class_literal_bool.html#afbb7178420daa4bdb73de244866c87bb">LiteralBool</a>, <a class="el" href="class_function_parameter.html#af2e9096c284fb3d91edb47b4f364cd9d">FunctionParameter</a>, <a class="el" href="class_block.html#a5529de52915f1f62751189bc1849b8d8">Block</a>, <a class="el" href="class_variable.html#acdb137025f39f81b4d2195c72806d5a9">Variable</a>, <a class="el" href="class_call_external.html#a920f6f3e704148495d7136b125727d97">CallExternal</a>, <a class="el" href="class_matrix_element_ref.html#ac96fb0313a201accec759f4e29145cb4">MatrixElementRef</a>, <a class="el" href="class_var_assignm.html#aa341fc030b102c1c0715e7ef906a64dc">VarAssignm</a>, <a class="el" href="class_call.html#adee679186d21d26000947b1ebd3eac8a">Call</a>, <a class="el" href="class_if.html#a6b7190a509558cec2b9fa030018ca038">If</a>, <a class="el" href="class_matrix_assignm.html#adfebf64023cc310a7fcb04658890b33f">MatrixAssignm</a>, <a class="el" href="class_return.html#a6cee60731a0300cb00952b545dff0317">Return</a>, <a class="el" href="class_operator_expr.html#af75840471b304c2f5aefe00b2a3caefb">OperatorExpr</a>, <a class="el" href="class_for.html#a242bf6ba17a4d7ef7d5a1e07f15b4bb4">For</a>, <a class="el" href="class_transpose.html#a7e898b45b72a513d865a7733ba892999">Transpose</a>, <a class="el" href="class_unary_expr.html#a4686e69b40cb79c1cb9a083aef30b25a">UnaryExpr</a>, <a class="el" href="class_while.html#a5206c7e1b28237f33c6fd210d7fd9017">While</a>, and <a class="el" href="class_parameter_list.html#a4e41c20b45889ac06308409077747bf7">ParameterList</a>.</p>

</div>
</div>
<a id="aef1fab41e507f447fb47009a2bbfb403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1fab41e507f447fb47009a2bbfb403">&#9670;&nbsp;</a></span>castTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* AbstractNode::castTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts a node to type T which must be the specific derived class of the node to cast successfully. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The derived class of the node object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the casted object, or a std::logic_error if cast was unsuccessful. </dd></dl>

</div>
</div>
<a id="ab7f13808b586865a27e2635995be5056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f13808b586865a27e2635995be5056">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_abstract_node.html">AbstractNode</a>* AbstractNode::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepOriginalUniqueNodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clones a node recursively, i.e., by including all of its children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepOriginalUniqueNodeId</td><td>Specifies whether to keep all of the unique node IDs of the original nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A clone of the node including clones of all of its children. </dd></dl>

<p>Implemented in <a class="el" href="class_abstract_matrix.html#ab0233364480213fd88222bbe664505f6">AbstractMatrix</a>, <a class="el" href="class_matrix.html#a3741150186f463585ef6bbe6dc178d06">Matrix&lt; T &gt;</a>, <a class="el" href="class_operator.html#aa2a10cc2f4df91bc5b5e86dcdf32339a">Operator</a>, <a class="el" href="class_rotate.html#a5abbbe7ffec7e2d35352b972c3e3ae33">Rotate</a>, <a class="el" href="class_get_matrix_size.html#a47a0a008a1db279bffa262f36bea27c9">GetMatrixSize</a>, <a class="el" href="class_logical_expr.html#a5e9d652657c8f2c75ab7e87fd0b8e30a">LogicalExpr</a>, <a class="el" href="class_literal_float.html#ab672122ac5d09db99e51b6a6cd6f8c68">LiteralFloat</a>, <a class="el" href="class_literal_string.html#aada7eb6ee1c8351f428230b584fbd63f">LiteralString</a>, <a class="el" href="class_literal_bool.html#a9147febcb58dc100e227caf55f9cc93c">LiteralBool</a>, <a class="el" href="class_literal_int.html#ab616cea25f71aea05400283aa7a8a8e1">LiteralInt</a>, <a class="el" href="class_return.html#a9ee16d778fe2682624e3569225d3258d">Return</a>, <a class="el" href="class_arithmetic_expr.html#a86db8c56a0699f83c6550a6490379d40">ArithmeticExpr</a>, <a class="el" href="class_var_decl.html#a97a3b21c31ee3a938cd77860efad47e4">VarDecl</a>, <a class="el" href="class_matrix_assignm.html#a7d156088099dbac8ffe7c9be557581a1">MatrixAssignm</a>, <a class="el" href="class_matrix_element_ref.html#aef61dda66b411fb7eb3021f4cd4a71a9">MatrixElementRef</a>, <a class="el" href="class_datatype.html#a064cead1bca53534dd2a6ff4e63224db">Datatype</a>, <a class="el" href="class_variable.html#a513ef74c9829ae07671deea65e19e213">Variable</a>, <a class="el" href="class_call_external.html#acbc9c298b704c9c3fe7a6cbbd8678ef8">CallExternal</a>, <a class="el" href="class_for.html#a9df10b4656f25290c00033755f507a25">For</a>, <a class="el" href="class_function_parameter.html#a8f4689709e8f19a441da091a0cee72a4">FunctionParameter</a>, <a class="el" href="class_transpose.html#a8325bb4823d808078645850ce94ecd35">Transpose</a>, <a class="el" href="class_function.html#a496b1999a8d36974c2f3b0330bc1d864">Function</a>, <a class="el" href="class_var_assignm.html#a25df11e98d9b65ce544a65f622bf32ff">VarAssignm</a>, <a class="el" href="class_block.html#a397d47dac4688ee58bac781384ce7751">Block</a>, <a class="el" href="class_call.html#ab12b25280f537a8783e385f5a7cd8d6e">Call</a>, <a class="el" href="class_if.html#aee0736d948c99f51e52ee2c4760cd6e7">If</a>, <a class="el" href="class_operator_expr.html#a167d2ed639a23ac9b6ea76a18b8b3514">OperatorExpr</a>, <a class="el" href="class_parameter_list.html#a3e263333a1f6be874dbb34b52743a32a">ParameterList</a>, <a class="el" href="class_unary_expr.html#ab7da0e8e91e4db4227973cb888c10ca8">UnaryExpr</a>, <a class="el" href="class_while.html#a4450f80c086cfd5e4c9b0bcdaeb249c5">While</a>, and <a class="el" href="class_matrix.html#a32b557782a90d3936e800a32b1d471e6">Matrix&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a267513a1115e86df8966caf998e71e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267513a1115e86df8966caf998e71e0e">&#9670;&nbsp;</a></span>cloneFlat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * AbstractNode::cloneFlat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a flat copy of the node without including any parents or children. </p><dl class="section return"><dt>Returns</dt><dd>A flat copy of this node. </dd></dl>

<p>Reimplemented in <a class="el" href="class_matrix_element_ref.html#a473e4dd6b0ff7f2657b1cc3fb79e376c">MatrixElementRef</a>, <a class="el" href="class_logical_expr.html#a3f2bef38e0450c0e42171eec6d891de0">LogicalExpr</a>, <a class="el" href="class_transpose.html#a334fe5d63a8c508d8ee258fdead5dea7">Transpose</a>, <a class="el" href="class_rotate.html#aa59a2aa6d51d963df3a1693ac73a687f">Rotate</a>, <a class="el" href="class_datatype.html#a96155ca202dcc91889df8b42b1e61365">Datatype</a>, and <a class="el" href="class_block.html#a9a7c663e3a1c2e3796dfacc45758964c">Block</a>.</p>

</div>
</div>
<a id="a3f200a84bf9e925ca39a6866a4d43588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f200a84bf9e925ca39a6866a4d43588">&#9670;&nbsp;</a></span>generateOutputString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AbstractNode::generateOutputString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printChildren</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates an output string to be used by the <a class="el" href="class_abstract_node.html#aee58b60a470f2e494e0db1808c87b13d">toString()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">printChildren</td><td>Specifies whether to print details of this node only (False) or also its children (True). </td></tr>
    <tr><td class="paramname">attributes</td><td>The node's attributes to be printed (fields in the node's class). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the node. </dd></dl>

</div>
</div>
<a id="a53eabf948b80068841182ec9987db78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eabf948b80068841182ec9987db78b">&#9670;&nbsp;</a></span>generateUniqueNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AbstractNode::generateUniqueNodeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a new node ID in the form "&lt;NodeTypeName&gt;_nodeIdCounter" where &lt;NodeTypeName&gt; is the value obtained by <a class="el" href="class_abstract_node.html#a8cc40127801e7777c8094f17a3b1efcb">getNodeType()</a> and nodeIdCounter an ongoing counter of created <a class="el" href="class_abstract_node.html">AbstractNode</a> objects. </p><dl class="section return"><dt>Returns</dt><dd>An unique node ID to be used as uniqueNodeId for the current node. </dd></dl>

</div>
</div>
<a id="ad585516679d3c13dea9dbe86afbf6e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad585516679d3c13dea9dbe86afbf6e6b">&#9670;&nbsp;</a></span>getAndIncrementNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractNode::getAndIncrementNodeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current ID (integer) and increments the ID by one. The ID is an ongoing counter of created <a class="el" href="class_abstract_node.html">AbstractNode</a> objects and is used to build an <a class="el" href="class_abstract_node.html">AbstractNode</a>'s unique ID (see <a class="el" href="class_abstract_node.html#a8c5441e6f42332beaa1291139986f800">getUniqueNodeId()</a>). </p><dl class="section return"><dt>Returns</dt><dd>The current ID as integer. </dd></dl>

</div>
</div>
<a id="a8cc40127801e7777c8094f17a3b1efcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc40127801e7777c8094f17a3b1efcb">&#9670;&nbsp;</a></span>getNodeType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string AbstractNode::getNodeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the node's type, which is the name of the object in the AST. This method must be overridden by all classes that inherit from <a class="el" href="class_abstract_node.html">AbstractNode</a> by their respective name (e.g., ArithmeticExp, <a class="el" href="class_function.html" title="Function has two children: First, a ParameterList and then a Block with the actual function Body.">Function</a>, <a class="el" href="class_variable.html">Variable</a>). </p><dl class="section return"><dt>Returns</dt><dd>The name of the node type. </dd></dl>

<p>Implemented in <a class="el" href="class_matrix.html#a3b0cb9df1fe3fccc0ac01fa4bcff664e">Matrix&lt; T &gt;</a>, <a class="el" href="class_function.html#a20b5ce420405c44241fc130ce2aaaf5a">Function</a>, <a class="el" href="class_var_decl.html#ab972180732b4454c2a32671ea02b8068">VarDecl</a>, <a class="el" href="class_arithmetic_expr.html#acce01879a087609d4565a051d753d810">ArithmeticExpr</a>, <a class="el" href="class_operator.html#af484b0fafd9c53fdd42ce0d29d882719">Operator</a>, <a class="el" href="class_literal_float.html#a0d8f9296eaa5ab54dab0d96ed45ec5e9">LiteralFloat</a>, <a class="el" href="class_literal_string.html#a3b0ac84bf4d0a27703056118f318b15e">LiteralString</a>, <a class="el" href="class_literal_bool.html#aefd23aa0f2fe77b8ff95af479f37c458">LiteralBool</a>, <a class="el" href="class_literal_int.html#a93f3ac81e32a462e9610e5742702e83d">LiteralInt</a>, <a class="el" href="class_rotate.html#aa9ad0956f8ccf42d3fe7090b0fcd21bf">Rotate</a>, <a class="el" href="class_logical_expr.html#a923a42bb3cb6dce80865efbde7b06b28">LogicalExpr</a>, <a class="el" href="class_get_matrix_size.html#a8433bf55f4f65961fddbebfaf381ef7c">GetMatrixSize</a>, <a class="el" href="class_call_external.html#aaa86d30b577ae5daa404e5ce3d0b6118">CallExternal</a>, <a class="el" href="class_var_assignm.html#a794b118aaaeae19f8d3d0e24aaea8d60">VarAssignm</a>, <a class="el" href="class_block.html#a0c4c888e1fda4a10ed73c1549ad8d6ed">Block</a>, <a class="el" href="class_call.html#a952035228f533511f97fccfcfac86bde">Call</a>, <a class="el" href="class_variable.html#a0ca604c78fc4cb70ea4dd94a07c9a6a0">Variable</a>, <a class="el" href="class_function_parameter.html#ab4d4e1a21f566ebac16556ce1cb661ff">FunctionParameter</a>, <a class="el" href="class_if.html#ab89f37630b8e717e97cd7405a4e3ab55">If</a>, <a class="el" href="class_unary_expr.html#affa2c2e7793d8ef8559abb72ab94db55">UnaryExpr</a>, <a class="el" href="class_while.html#ad5e769ff017d252704b5627a3c6e97ff">While</a>, <a class="el" href="class_return.html#a7b756560b61c5d7d53f4e18f3b3e7ce4">Return</a>, <a class="el" href="class_operator_expr.html#afd089099466a37a0ba04afca1ef8b46a">OperatorExpr</a>, <a class="el" href="class_matrix_element_ref.html#a1d9db738389c8b6b8909c642f63bb70d">MatrixElementRef</a>, <a class="el" href="class_datatype.html#ab165c4733bd9852190931b6c24ff3135">Datatype</a>, <a class="el" href="class_matrix_assignm.html#ab0fc7e38657f84b29a650faa44557a37">MatrixAssignm</a>, <a class="el" href="class_for.html#a30fa9a5a99952989e54e16cd702f1283">For</a>, <a class="el" href="class_transpose.html#afab79262535b6cf8e9936a8021991239">Transpose</a>, and <a class="el" href="class_parameter_list.html#aa20ebf072891d797392a2723b3275333">ParameterList</a>.</p>

</div>
</div>
<a id="a8c5441e6f42332beaa1291139986f800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5441e6f42332beaa1291139986f800">&#9670;&nbsp;</a></span>getUniqueNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AbstractNode::getUniqueNodeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a node's unique ID, or generates it by calling <a class="el" href="class_abstract_node.html#a53eabf948b80068841182ec9987db78b">generateUniqueNodeId()</a> if the name was not defined yet. </p><dl class="section return"><dt>Returns</dt><dd>The node's name consisting of the node type and an ongoing number (e.g., Function_1). </dd></dl>

</div>
</div>
<a id="a3905c64474339cfcf742f982633364e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3905c64474339cfcf742f982633364e9">&#9670;&nbsp;</a></span>hasReversedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractNode::hasReversedEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the edges of this node are reversed (i.e., node's parents and children are swapped). </p><dl class="section return"><dt>Returns</dt><dd>True iff the node's edges are reversed. </dd></dl>

</div>
</div>
<a id="af0df7a9545812739bb59d122a51ba99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0df7a9545812739bb59d122a51ba99c">&#9670;&nbsp;</a></span>resetNodeIdCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::resetNodeIdCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the static node ID counter that is used to build the unique node ID. This method is required for testing. </p>

</div>
</div>
<a id="aad720dd5baeb746174fc08c8500cd2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad720dd5baeb746174fc08c8500cd2eb">&#9670;&nbsp;</a></span>setUniqueNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::setUniqueNodeId </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newUniqueNodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the uniqueNodeId attribute. This attribute should be auto-generated by <a class="el" href="class_abstract_node.html#a53eabf948b80068841182ec9987db78b">generateUniqueNodeId()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newUniqueNodeId</td><td>The new unique node's identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76f2290759cb522619af77c630b6eba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f2290759cb522619af77c630b6eba9">&#9670;&nbsp;</a></span>supportsCircuitMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractNode::supportsCircuitMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns True iff the class derived from the <a class="el" href="class_abstract_node.html">AbstractNode</a> class properly makes use of the child/parent fields as it would be expected in a circuit. </p>

<p>Reimplemented in <a class="el" href="class_matrix.html#a0f5917a0bdd141b306673104a93bdec2">Matrix&lt; T &gt;</a>, <a class="el" href="class_operator.html#aead298af5c61f58d0d5e15740ad3ded0">Operator</a>, <a class="el" href="class_var_decl.html#adcc8c11c783bd96e671dc2964b6efcdb">VarDecl</a>, <a class="el" href="class_function.html#ab52f1f00cd8910e6909e3ee8638295b1">Function</a>, <a class="el" href="class_literal_bool.html#aa4ddaa4e1e10d884db83b88d6ea8003f">LiteralBool</a>, <a class="el" href="class_literal_int.html#a933cfa1c13fec1fd7ccb8069bd74e872">LiteralInt</a>, <a class="el" href="class_datatype.html#a8f44424fb88fa15d859bfce21dda79b7">Datatype</a>, <a class="el" href="class_literal_float.html#a35eced8d53a78e3900252d8f0581d25f">LiteralFloat</a>, <a class="el" href="class_literal_string.html#af7943135197a8f23a317b0aed4e29484">LiteralString</a>, <a class="el" href="class_variable.html#a8e6652c2d761143e7e1257a4453de141">Variable</a>, <a class="el" href="class_get_matrix_size.html#aa040fd5eab5d44fdf5f4f4e7c8b68201">GetMatrixSize</a>, <a class="el" href="class_matrix_element_ref.html#ab66143ebf27d337e9f05eca645012813">MatrixElementRef</a>, <a class="el" href="class_for.html#ab03893b429564e0d60af629286426bbc">For</a>, <a class="el" href="class_return.html#a398c1aa6b27d886f4b5a18036da7ef27">Return</a>, <a class="el" href="class_var_assignm.html#ab9ef7e475cd00557e19e21f2eea1011c">VarAssignm</a>, <a class="el" href="class_call.html#aa6229befb6eefbd8d21e822570417e9b">Call</a>, <a class="el" href="class_transpose.html#aa4d2979b5c763808af9b39e61c058a04">Transpose</a>, <a class="el" href="class_unary_expr.html#a11038714885c438c11ae0f12636fcc66">UnaryExpr</a>, <a class="el" href="class_block.html#a1d418c6c69e78d5aca2cd125ae5a3b43">Block</a>, <a class="el" href="class_function_parameter.html#af31c38bc762221a5a1f7baea138a7e0d">FunctionParameter</a>, <a class="el" href="class_if.html#a39631269a6877aee80eec6e89312f9bd">If</a>, <a class="el" href="class_rotate.html#add019d896fc9d22baf6054fcdb35b14e">Rotate</a>, <a class="el" href="class_while.html#ab416b063b2aadcae8a40a3f44131d81d">While</a>, <a class="el" href="class_operator_expr.html#ae71d874f2823162f7432cf979cea8f60">OperatorExpr</a>, <a class="el" href="class_matrix_assignm.html#a62bb1be891af4760493b0996e27d7dce">MatrixAssignm</a>, <a class="el" href="class_abstract_binary_expr.html#a5d17aeb275587b0fd92d457a3454acdb">AbstractBinaryExpr</a>, and <a class="el" href="class_parameter_list.html#ad8739af533a7a3750d93ba4e7a461bfc">ParameterList</a>.</p>

</div>
</div>
<a id="a2479945fea5f323f14ac1a5f8615aad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2479945fea5f323f14ac1a5f8615aad6">&#9670;&nbsp;</a></span>swapChildrenParents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::swapChildrenParents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the children and parents vectors which corresponds to flipping the edges of this node. Note: This should never be performed on individual nodes only but instead on the whole AST, see method <a class="el" href="class_ast.html#af804ef1601108ac47577715b9212e295" title="Reverses all edges by switching child and parent nodes of each reachable node within the AST.">Ast::reverseEdges()</a>. Keep in mind that most methods are not aware of this swapped relationship and do not work. Use *getChildAtIndex(int idx, bool isEdgeDirectionAware) by specifying isEdgeDirectionAware=true to get a specific child. </p>

</div>
</div>
<a id="a0ee4c4915b6f76415aa2187535359899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee4c4915b6f76415aa2187535359899">&#9670;&nbsp;</a></span>toJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">json AbstractNode::toJson </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the JSON representation of the node including all of its children. </p><dl class="section return"><dt>Returns</dt><dd>JSON representation of the node </dd></dl>

<p>Reimplemented in <a class="el" href="class_abstract_matrix.html#a951b47fa76fbbf7854d6476144c348da">AbstractMatrix</a>, <a class="el" href="class_matrix.html#a90298e7f3b73138b6fc29cefb43524d5">Matrix&lt; T &gt;</a>, <a class="el" href="class_datatype.html#a5f35d4e99b310e9bac46fcc03f7e3982">Datatype</a>, <a class="el" href="class_for.html#adaaf55403e32fa675817302dede735a7">For</a>, <a class="el" href="class_function.html#a0abba29af8d918c9dc310b999ad929ed">Function</a>, <a class="el" href="class_var_decl.html#acab217ec9794a1d18443617472cab88d">VarDecl</a>, <a class="el" href="class_literal_float.html#a59246dcdc2291cc5a79f51133efcd84a">LiteralFloat</a>, <a class="el" href="class_literal_int.html#a0a72ff976a6747d9a32735493c25c36a">LiteralInt</a>, <a class="el" href="class_abstract_expr.html#ac1957d8bda1e29b35b822ec0b05c5027">AbstractExpr</a>, <a class="el" href="class_literal_string.html#a215987e5d1874f1d3de818885ff5b149">LiteralString</a>, <a class="el" href="class_literal_bool.html#a1f09331096aa475a6d92870e33280d15">LiteralBool</a>, <a class="el" href="class_matrix_assignm.html#ae9400d961f74bb991538ad65a7d7527a">MatrixAssignm</a>, <a class="el" href="class_get_matrix_size.html#a674073531ae6bc4c772da6386e6e5c72">GetMatrixSize</a>, <a class="el" href="class_matrix_element_ref.html#a336ce656eb1f92cb11c1429066c9e331">MatrixElementRef</a>, <a class="el" href="class_rotate.html#a0e65e2d7c7b367b1519101c994a502e5">Rotate</a>, <a class="el" href="class_block.html#a424cf07d24308a8f37dedb1d67076059">Block</a>, <a class="el" href="class_call_external.html#a29480977d4043815acd01bbbe6aa9688">CallExternal</a>, <a class="el" href="class_function_parameter.html#a142f3e7fed261ce9b4717486c12ac61d">FunctionParameter</a>, <a class="el" href="class_transpose.html#a50e8ff05ff7ee447c4ffb910d191c6c4">Transpose</a>, <a class="el" href="class_var_assignm.html#a1acd73b8bf7c8640b75066f6dba3f2f8">VarAssignm</a>, <a class="el" href="class_abstract_binary_expr.html#a37df209d914bb3104689caf8e3e93cdf">AbstractBinaryExpr</a>, <a class="el" href="class_call.html#a1b1a81d3dcc202fb3db99eceb10ef3c6">Call</a>, <a class="el" href="class_if.html#a1db56ab3b121d15c5bd11083006efa33">If</a>, <a class="el" href="class_return.html#a89eb5ab24aaa10a8ff4c9aba68fc1abb">Return</a>, <a class="el" href="class_variable.html#ad2de73d36aa8d372c3f0458ad717260c">Variable</a>, <a class="el" href="class_abstract_statement.html#a9ec419479db2dfefcd70042f94974949">AbstractStatement</a>, <a class="el" href="class_unary_expr.html#a6469f7794fb2db18817e511e786f4517">UnaryExpr</a>, <a class="el" href="class_while.html#ae2cc03fb2b18993573ff4b3b0c0442fb">While</a>, and <a class="el" href="class_matrix.html#a9c2e653926b1d5e04bac5c838724c70f">Matrix&lt; T &gt;</a>.</p>

</div>
</div>
<a id="aee58b60a470f2e494e0db1808c87b13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee58b60a470f2e494e0db1808c87b13d">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AbstractNode::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>printChildren</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of the node, if printChildren is True then calls toString for its children too. Hence, toString(false) is equivalent to printing a node's attributes only. </p><dl class="section return"><dt>Returns</dt><dd>A textual representation of the node. </dd></dl>

<p>Reimplemented in <a class="el" href="class_operator.html#a74ac2d3c1f1fe6c0f7562f993c643f72">Operator</a>, <a class="el" href="class_var_decl.html#a42ea504f3b66ae2db062f00a34ac0ed3">VarDecl</a>, <a class="el" href="class_function.html#a3859937a4088b24c1d74cf978c322258">Function</a>, <a class="el" href="class_literal_int.html#a9e63664ada0aae614b102e77184a7367">LiteralInt</a>, <a class="el" href="class_literal_float.html#a306d4f78a9a6e3fb4bd96ed80ad71b3d">LiteralFloat</a>, <a class="el" href="class_literal_string.html#a11b734827885bdba66e0e33c34944a73">LiteralString</a>, <a class="el" href="class_literal_bool.html#a29b5893e791907dbc842a9def7be047f">LiteralBool</a>, <a class="el" href="class_arithmetic_expr.html#abf4e507de6c63f951de09791522f69a4">ArithmeticExpr</a>, <a class="el" href="class_function_parameter.html#a3f9b0368be2fb20f4c7fa22cc3405608">FunctionParameter</a>, <a class="el" href="class_var_assignm.html#a650129d8d9e4108d087a82f5ebd8d5b3">VarAssignm</a>, <a class="el" href="class_variable.html#ab214930aad392d3d3c73e4ba325ee85e">Variable</a>, <a class="el" href="class_logical_expr.html#ae14a23462d6891753a82d196cbfa7e54">LogicalExpr</a>, <a class="el" href="class_datatype.html#afb612b24f8d8e4fa23210e4f3784f53e">Datatype</a>, <a class="el" href="class_if.html#a4a74847a522cb1857fb4e0d2961332d6">If</a>, <a class="el" href="class_for.html#a32cfa5cded4c0ba91e24b8607a85705b">For</a>, <a class="el" href="class_get_matrix_size.html#a42db7c23f0766d24119969233d7455a7">GetMatrixSize</a>, <a class="el" href="class_matrix_element_ref.html#a78252162bcb1f77089bfbe2d5c875f25">MatrixElementRef</a>, <a class="el" href="class_block.html#ad4ff57dba6103f81e120470c81025ddf">Block</a>, <a class="el" href="class_return.html#a992860dd4e2e7ff4b4aa7f250ce663e7">Return</a>, <a class="el" href="class_transpose.html#a78261ff7341c7e20403394946fef4f1d">Transpose</a>, <a class="el" href="class_unary_expr.html#a48903d55435a5c489c45d9dbcf84a10b">UnaryExpr</a>, <a class="el" href="class_rotate.html#a580de20c68b39d4d6cfd6c0bd373839b">Rotate</a>, <a class="el" href="class_parameter_list.html#ac7d757105ce57060b3c7e2c028e8ee9e">ParameterList</a>, <a class="el" href="class_operator_expr.html#a1cb51241e205a0683ac79ffd6b1a3138">OperatorExpr</a>, and <a class="el" href="class_matrix_assignm.html#a69191bd7e431a12ef96b2fd2b752833d">MatrixAssignm</a>.</p>

</div>
</div>
<a id="a6eeef4bb93c1788d6ebce8ab634d9045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eeef4bb93c1788d6ebce8ab634d9045">&#9670;&nbsp;</a></span>updateClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractNode::updateClone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepOriginalUniqueNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>originalNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method that updates a cloned node. Must be called within each derived <a class="el" href="class_abstract_node.html#ab7f13808b586865a27e2635995be5056">clone()</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepOriginalUniqueNodeId</td><td>Determines whether to replace the cloned node's unique node ID by the ID of the original node. </td></tr>
    <tr><td class="paramname">originalNode</td><td>The node of which the cloned node is based on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a864ad3a5c7ab4da0651ea1369965fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864ad3a5c7ab4da0651ea1369965fe00">&#9670;&nbsp;</a></span>assignedNodeId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractNode::assignedNodeId {-1}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the reserved node ID until the first call of <a class="el" href="class_abstract_node.html#a8c5441e6f42332beaa1291139986f800">getUniqueNodeId()</a> at which the reserved ID is fetched and the node's ID is assigned (field uniqueNodeId) based on the node's name and this reserved ID. This is a workaround because <a class="el" href="class_abstract_node.html#a8cc40127801e7777c8094f17a3b1efcb">getNodeType()</a> is a virtual method that cannot be called from derived classes' constructor. </p>

</div>
</div>
<a id="ab3d626a24e6c737b61d4cd0aa0b36a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d626a24e6c737b61d4cd0aa0b36a43">&#9670;&nbsp;</a></span>nodeIdCounter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractNode::nodeIdCounter = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static ongoing counter that is incremented after creating a new <a class="el" href="class_abstract_node.html">AbstractNode</a> object. The counter's value is used to build the unique node ID. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/ast/<a class="el" href="_abstract_node_8h_source.html">AbstractNode.h</a></li>
<li>src/ast/AbstractNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
