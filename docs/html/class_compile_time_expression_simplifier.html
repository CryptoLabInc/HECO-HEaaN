<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AST Optimizer for FHE: CompileTimeExpressionSimplifier Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AST Optimizer for FHE
   </div>
   <div id="projectbrief">An optimizer for FHE-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_compile_time_expression_simplifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CompileTimeExpressionSimplifier Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for CompileTimeExpressionSimplifier:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_compile_time_expression_simplifier.png" usemap="#CompileTimeExpressionSimplifier_map" alt=""/>
  <map id="CompileTimeExpressionSimplifier_map" name="CompileTimeExpressionSimplifier_map">
<area href="class_visitor.html" alt="Visitor" shape="rect" coords="0,0,197,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gadb18aff7e469b23a11c185cb3e1e1c1c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_abstract_expr.html">AbstractExpr</a> &amp;elem) override</td></tr>
<tr class="separator:gadb18aff7e469b23a11c185cb3e1e1c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984ce2d337fa12c57814b21c1333023c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_abstract_node.html">AbstractNode</a> &amp;elem) override</td></tr>
<tr class="separator:ga984ce2d337fa12c57814b21c1333023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga916e255e78e6b34af50c5b9aa82a12ca"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_abstract_statement.html">AbstractStatement</a> &amp;elem) override</td></tr>
<tr class="separator:ga916e255e78e6b34af50c5b9aa82a12ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003d48f6d1fb9eec7eaec00989ecf8bf"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_arithmetic_expr.html">ArithmeticExpr</a> &amp;elem) override</td></tr>
<tr class="separator:ga003d48f6d1fb9eec7eaec00989ecf8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5403301a4ee22db8e54b3746192f8d36"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_abstract_matrix.html">AbstractMatrix</a> &amp;elem) override</td></tr>
<tr class="separator:ga5403301a4ee22db8e54b3746192f8d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e310077a51158ba211d39a0c4cb8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__visit.html#ga10e310077a51158ba211d39a0c4cb8de">visit</a> (<a class="el" href="class_ast.html">Ast</a> &amp;elem) override</td></tr>
<tr class="separator:ga10e310077a51158ba211d39a0c4cb8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c3b4c07a86afc8605aff83bcb9f73f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_block.html">Block</a> &amp;elem) override</td></tr>
<tr class="separator:gad1c3b4c07a86afc8605aff83bcb9f73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39523314965a8fbcceabbf94be8ae48b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_call.html">Call</a> &amp;elem) override</td></tr>
<tr class="separator:ga39523314965a8fbcceabbf94be8ae48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6610cef2bbf336e09be4c357fb2de57f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_call_external.html">CallExternal</a> &amp;elem) override</td></tr>
<tr class="separator:ga6610cef2bbf336e09be4c357fb2de57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd76ce33b0b1210cf9995f64e19eebef"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_datatype.html">Datatype</a> &amp;elem) override</td></tr>
<tr class="separator:gadd76ce33b0b1210cf9995f64e19eebef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a55950004d459cfe352266f09ba0489"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_function.html">Function</a> &amp;elem) override</td></tr>
<tr class="separator:ga9a55950004d459cfe352266f09ba0489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be86bdebcc462d4cb8f12b8988a88fe"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_function_parameter.html">FunctionParameter</a> &amp;elem) override</td></tr>
<tr class="separator:ga4be86bdebcc462d4cb8f12b8988a88fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga003dc9b7841e601218824eeb9f5d1544"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_for.html">For</a> &amp;elem) override</td></tr>
<tr class="separator:ga003dc9b7841e601218824eeb9f5d1544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3980f5b87392fa3b601e99aecd8b9c57"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_matrix_element_ref.html">MatrixElementRef</a> &amp;elem) override</td></tr>
<tr class="separator:ga3980f5b87392fa3b601e99aecd8b9c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03eb127f71d5d8f606856dd54b1c7d2"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_get_matrix_size.html">GetMatrixSize</a> &amp;elem) override</td></tr>
<tr class="separator:gac03eb127f71d5d8f606856dd54b1c7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92346e934c4858b6a20a67caadfc934"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_if.html">If</a> &amp;elem) override</td></tr>
<tr class="separator:gab92346e934c4858b6a20a67caadfc934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga062cfb52a658896900d111a579b0f5cc"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_literal_bool.html">LiteralBool</a> &amp;elem) override</td></tr>
<tr class="separator:ga062cfb52a658896900d111a579b0f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a1859a66d9e335d10440ef9c64b855"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_literal_float.html">LiteralFloat</a> &amp;elem) override</td></tr>
<tr class="separator:ga32a1859a66d9e335d10440ef9c64b855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4a35b74f7f62ec5d05cc2f5e0e7c5de"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_literal_int.html">LiteralInt</a> &amp;elem) override</td></tr>
<tr class="separator:gae4a35b74f7f62ec5d05cc2f5e0e7c5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f7c9fc44bbf47a18cb861c82a99ad9"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_literal_string.html">LiteralString</a> &amp;elem) override</td></tr>
<tr class="separator:gaa4f7c9fc44bbf47a18cb861c82a99ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007a2a946273572d4b9420eb4995447f"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_logical_expr.html">LogicalExpr</a> &amp;elem) override</td></tr>
<tr class="separator:ga007a2a946273572d4b9420eb4995447f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21957a2874b9cd4ca5a1ddd2227e863d"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_operator.html">Operator</a> &amp;elem) override</td></tr>
<tr class="separator:ga21957a2874b9cd4ca5a1ddd2227e863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d42104d9f5e481f754c71eee2bb558"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_operator_expr.html">OperatorExpr</a> &amp;elem) override</td></tr>
<tr class="separator:ga20d42104d9f5e481f754c71eee2bb558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ae325396b4c7c4bc76a62264539a4"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_parameter_list.html">ParameterList</a> &amp;elem) override</td></tr>
<tr class="separator:ga593ae325396b4c7c4bc76a62264539a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae19504de46d8cbc9bbc33e65c4eedf"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_return.html">Return</a> &amp;elem) override</td></tr>
<tr class="separator:gadae19504de46d8cbc9bbc33e65c4eedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef097cea74d5d684ee9d9ba9f1636c4c"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_unary_expr.html">UnaryExpr</a> &amp;elem) override</td></tr>
<tr class="separator:gaef097cea74d5d684ee9d9ba9f1636c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0202556283dc5808cdfa5b1fb5575009"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_var_assignm.html">VarAssignm</a> &amp;elem) override</td></tr>
<tr class="separator:ga0202556283dc5808cdfa5b1fb5575009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea2bd416e02be4a774dda9c47f8e5f77"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_var_decl.html">VarDecl</a> &amp;elem) override</td></tr>
<tr class="separator:gaea2bd416e02be4a774dda9c47f8e5f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9942b4af59d40109e43d48566c3f7f6b"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_variable.html">Variable</a> &amp;elem) override</td></tr>
<tr class="separator:ga9942b4af59d40109e43d48566c3f7f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97d3a595aa827fb20a4416b0b6b01c95"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_while.html">While</a> &amp;elem) override</td></tr>
<tr class="separator:ga97d3a595aa827fb20a4416b0b6b01c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8630d5219e3a144e15554795619beff1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_rotate.html">Rotate</a> &amp;elem) override</td></tr>
<tr class="separator:ga8630d5219e3a144e15554795619beff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b7ffe8bd5f11f5f1fdd6b99292dc61"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_matrix_assignm.html">MatrixAssignm</a> &amp;elem) override</td></tr>
<tr class="separator:gad0b7ffe8bd5f11f5f1fdd6b99292dc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf818ef6c9a0b336d1b469ad4eb42d5d5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>visit</b> (<a class="el" href="class_transpose.html">Transpose</a> &amp;elem) override</td></tr>
<tr class="separator:gaf818ef6c9a0b336d1b469ad4eb42d5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6478142374de1a96867c6f89720ca3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#acc6478142374de1a96867c6f89720ca3">hasKnownValue</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *node)</td></tr>
<tr class="separator:acc6478142374de1a96867c6f89720ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05945043cd0586ea24f2b9d4f8d8ff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#af05945043cd0586ea24f2b9d4f8d8ff8">markNodeAsRemovable</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *node)</td></tr>
<tr class="separator:af05945043cd0586ea24f2b9d4f8d8ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b4da6ae653865e6ceed19d1936a0de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#ac8b4da6ae653865e6ceed19d1936a0de">getKnownValue</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *node)</td></tr>
<tr class="separator:ac8b4da6ae653865e6ceed19d1936a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9070fa0325013412b208f4fc2aa5d552"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a9070fa0325013412b208f4fc2aa5d552">evaluateNodeRecursive</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *node, std::unordered_map&lt; std::string, <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt; valuesOfVariables)</td></tr>
<tr class="separator:a9070fa0325013412b208f4fc2aa5d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0fda043df118abeeb41e1fd4dd5c6c"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#aff0fda043df118abeeb41e1fd4dd5c6c">getTransformedVariableMap</a> ()</td></tr>
<tr class="separator:aff0fda043df118abeeb41e1fd4dd5c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c200ac987ce33d137d1fc24c14a83a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a1c200ac987ce33d137d1fc24c14a83a4">cleanUpAfterStatementVisited</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *statement, bool enqueueStatementForDeletion=false)</td></tr>
<tr class="separator:a1c200ac987ce33d137d1fc24c14a83a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f21eb6a481f3cdc6c18a807ec9bb481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a1f21eb6a481f3cdc6c18a807ec9bb481">addDeclaredVariable</a> (std::string varIdentifier, <a class="el" href="class_datatype.html">Datatype</a> *dType, <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *value)</td></tr>
<tr class="separator:a1f21eb6a481f3cdc6c18a807ec9bb481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cb29d4b29bff0ade58a6633d8f7b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a00cb29d4b29bff0ade58a6633d8f7b71">setVariableValue</a> (const std::string &amp;variableIdentifier, <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *valueAnyLiteralOrAbstractExpr)</td></tr>
<tr class="separator:a00cb29d4b29bff0ade58a6633d8f7b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75588a958c194e9e426d543c2d1ce3f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a75588a958c194e9e426d543c2d1ce3f1">isQueuedForDeletion</a> (const <a class="el" href="class_abstract_node.html">AbstractNode</a> *node)</td></tr>
<tr class="separator:a75588a958c194e9e426d543c2d1ce3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad032b5b9af518c40bcfc7c4d3e8cc64c"><td class="memItemLeft" align="right" valign="top">VariableValuesMapType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#ad032b5b9af518c40bcfc7c4d3e8cc64c">getChangedVariables</a> (VariableValuesMapType variableValuesBeforeVisitingNode)</td></tr>
<tr class="separator:ad032b5b9af518c40bcfc7c4d3e8cc64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca5d9e165382fd86bd831360078ad57"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::pair&lt; std::string, <a class="el" href="class_scope.html">Scope</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a7ca5d9e165382fd86bd831360078ad57">removeVarsWrittenAndReadFromVariableValues</a> (<a class="el" href="class_block.html">Block</a> &amp;blockStmt)</td></tr>
<tr class="separator:a7ca5d9e165382fd86bd831360078ad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19863cb6e257e4b309a65ae08450bb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a19863cb6e257e4b309a65ae08450bb47">getVariableValueDeclaredInThisOrOuterScope</a> (std::string variableName)</td></tr>
<tr class="separator:a19863cb6e257e4b309a65ae08450bb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29db4fa6087db8db78ef531a094ca08b"><td class="memItemLeft" align="right" valign="top">VariableValuesMapType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a29db4fa6087db8db78ef531a094ca08b">getVariableEntryDeclaredInThisOrOuterScope</a> (std::string variableName)</td></tr>
<tr class="separator:a29db4fa6087db8db78ef531a094ca08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0d37c2122a173af72f610993067fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_var_assignm.html">VarAssignm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#ac1d0d37c2122a173af72f610993067fb">emitVariableAssignment</a> (VariableValuesMapType::iterator variableToEmit)</td></tr>
<tr class="separator:ac1d0d37c2122a173af72f610993067fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7b243ee43a5e5025b3d99304f6a256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#aed7b243ee43a5e5025b3d99304f6a256">emitVariableDeclaration</a> (std::map&lt; std::pair&lt; std::string, <a class="el" href="class_scope.html">Scope</a> * &gt;, <a class="el" href="struct_variable_value.html">VariableValue</a> * &gt;::iterator variableToEmit)</td></tr>
<tr class="separator:aed7b243ee43a5e5025b3d99304f6a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9558c06534da5a09d8022c031dd982b6"><td class="memItemLeft" align="right" valign="top">VariableValuesMapType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a9558c06534da5a09d8022c031dd982b6">getClonedVariableValuesMap</a> ()</td></tr>
<tr class="separator:a9558c06534da5a09d8022c031dd982b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac313617166dfcfa7e150a417975f4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#adac313617166dfcfa7e150a417975f4c">determineNumLoopIterations</a> (<a class="el" href="class_for.html">For</a> &amp;elem)</td></tr>
<tr class="separator:adac313617166dfcfa7e150a417975f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b591e8e43fe6290b5e56d02cb424cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a8b591e8e43fe6290b5e56d02cb424cfc">enqueueNodeForDeletion</a> (<a class="el" href="class_abstract_node.html">AbstractNode</a> *node)</td></tr>
<tr class="separator:a8b591e8e43fe6290b5e56d02cb424cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90268685049aacbf542f3fce396e738b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a90268685049aacbf542f3fce396e738b">setMatrixVariableValue</a> (const std::string &amp;variableIdentifier, int row, int column, <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *matrixElementValue)</td></tr>
<tr class="separator:a90268685049aacbf542f3fce396e738b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5778548f24ce6d174050436c95287a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a5778548f24ce6d174050436c95287a8f">handleForLoopUnrolling</a> (<a class="el" href="class_for.html">For</a> &amp;elem)</td></tr>
<tr class="separator:a5778548f24ce6d174050436c95287a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06897ae2ff2176c1f964014ca5b2c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#af06897ae2ff2176c1f964014ca5b2c76">doFullLoopUnrolling</a> (<a class="el" href="class_for.html">For</a> &amp;elem, int numLoopIterations)</td></tr>
<tr class="separator:af06897ae2ff2176c1f964014ca5b2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b89277cae83880dab22a9065be943e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a9b89277cae83880dab22a9065be943e5">doPartialLoopUnrolling</a> (<a class="el" href="class_for.html">For</a> &amp;elem)</td></tr>
<tr class="separator:a9b89277cae83880dab22a9065be943e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_visitor"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_visitor')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_visitor.html">Visitor</a></td></tr>
<tr class="memitem:ae9f53aada7fe369ecf7b476811669472 inherit pub_methods_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="ae9f53aada7fe369ecf7b476811669472"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setIgnoreScope</b> (bool ignScope)</td></tr>
<tr class="separator:ae9f53aada7fe369ecf7b476811669472 inherit pub_methods_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c34c12ced649c025350452ac0d1d9 inherit pub_methods_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="ae80c34c12ced649c025350452ac0d1d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>changeToOuterScope</b> ()</td></tr>
<tr class="separator:ae80c34c12ced649c025350452ac0d1d9 inherit pub_methods_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191506e1fa039e349a4c23e374236085 inherit pub_methods_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="a191506e1fa039e349a4c23e374236085"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>changeToInnerScope</b> (const std::string &amp;nodeId, <a class="el" href="class_abstract_statement.html">AbstractStatement</a> *statement)</td></tr>
<tr class="separator:a191506e1fa039e349a4c23e374236085 inherit pub_methods_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c88e84050c15780d77e622b8078380b inherit pub_methods_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="a6c88e84050c15780d77e622b8078380b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addStatementToScope</b> (<a class="el" href="class_abstract_statement.html">AbstractStatement</a> &amp;stat)</td></tr>
<tr class="separator:a6c88e84050c15780d77e622b8078380b inherit pub_methods_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3671d8c8f8c8b61885c9ddea9b0af639"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a3671d8c8f8c8b61885c9ddea9b0af639">generateIfDependentValue</a> (<a class="el" href="class_abstract_expr.html">AbstractExpr</a> *condition, <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *trueValue, <a class="el" href="class_abstract_expr.html">AbstractExpr</a> *falseValue)</td></tr>
<tr class="separator:a3671d8c8f8c8b61885c9ddea9b0af639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6133d91be73fe723689392bdade892e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a6133d91be73fe723689392bdade892e4">simplifyLogicalExpr</a> (<a class="el" href="class_operator_expr.html">OperatorExpr</a> &amp;elem)</td></tr>
<tr class="separator:a6133d91be73fe723689392bdade892e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac742ab530e2090d4154ea717efcfee1b"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#ac742ab530e2090d4154ea717efcfee1b">removableNodes</a></td></tr>
<tr class="separator:ac742ab530e2090d4154ea717efcfee1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2614357b812cde2f183025eebe936460"><td class="memItemLeft" align="right" valign="top">VariableValuesMapType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a2614357b812cde2f183025eebe936460">variableValues</a></td></tr>
<tr class="separator:a2614357b812cde2f183025eebe936460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a966eb79247b99396ad31efe46e0c3"><td class="memItemLeft" align="right" valign="top">std::deque&lt; <a class="el" href="class_abstract_node.html">AbstractNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#ac3a966eb79247b99396ad31efe46e0c3">nodesQueuedForDeletion</a></td></tr>
<tr class="separator:ac3a966eb79247b99396ad31efe46e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb269763a2f078201f628f8aa36055f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_compile_time_expression_simplifier.html#a2cb269763a2f078201f628f8aa36055f">replaceVariablesByValues</a> {true}</td></tr>
<tr class="separator:a2cb269763a2f078201f628f8aa36055f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_visitor"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_visitor')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_visitor.html">Visitor</a></td></tr>
<tr class="memitem:a75e8113cfc518f4c6bb3e42ba271c6cf inherit pub_attribs_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="a75e8113cfc518f4c6bb3e42ba271c6cf"></a>
<a class="el" href="class_scope.html">Scope</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>curScope</b></td></tr>
<tr class="separator:a75e8113cfc518f4c6bb3e42ba271c6cf inherit pub_attribs_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_visitor"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_visitor')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_visitor.html">Visitor</a></td></tr>
<tr class="memitem:ae280b2af655427a4fe4bcb1bae4ce705 inherit pro_attribs_class_visitor"><td class="memItemLeft" align="right" valign="top"><a id="ae280b2af655427a4fe4bcb1bae4ce705"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ignoreScope</b> {false}</td></tr>
<tr class="separator:ae280b2af655427a4fe4bcb1bae4ce705 inherit pro_attribs_class_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f21eb6a481f3cdc6c18a807ec9bb481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f21eb6a481f3cdc6c18a807ec9bb481">&#9670;&nbsp;</a></span>addDeclaredVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::addDeclaredVariable </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_datatype.html">Datatype</a> *&#160;</td>
          <td class="paramname"><em>dType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves information about a declared variable. Must include the variable's identifier, the variable's datatype, and optionally also an initializer (or nullptr otherwise). The method assumes that it is called from the variable's declaration scope, hence saves Visitor::curScope as the variable's declaration scope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varIdentifier</td><td>The identifier of the declared variable. </td></tr>
    <tr><td class="paramname">dType</td><td>The variable's datatype. </td></tr>
    <tr><td class="paramname">value</td><td>The variable's value, i.e., initializer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c200ac987ce33d137d1fc24c14a83a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c200ac987ce33d137d1fc24c14a83a4">&#9670;&nbsp;</a></span>cleanUpAfterStatementVisited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::cleanUpAfterStatementVisited </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>statement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enqueueStatementForDeletion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method must be called at the end of the visit(...) of each statement. The method makes sure that the binary expression accumulator is reset and if specified by enqueueStatementForDeletion=True, also marks the given statement for deletion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statement</td><td>The statement for which visit(...) was executed. </td></tr>
    <tr><td class="paramname">enqueueStatementForDeletion</td><td>True if this statement should be marked for deletion, otherwise False (default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac313617166dfcfa7e150a417975f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac313617166dfcfa7e150a417975f4c">&#9670;&nbsp;</a></span>determineNumLoopIterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CompileTimeExpressionSimplifier::determineNumLoopIterations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_for.html">For</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper method that simulates the execution of the given For-loop to determine the number of iterations the loop would be executed. <a class="el" href="class_if.html">If</a> variable values involved in the loop's condition are unknown, the method returns -1. Global data structures (e.g., variableValues or nodesQueuedForDeletion) are restored to their state before calling this method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The For-loop for that the number of loop iterations should be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of iterations or -1 if not all variables required to simulate the loop's execution are known. </dd></dl>

</div>
</div>
<a id="af06897ae2ff2176c1f964014ca5b2c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06897ae2ff2176c1f964014ca5b2c76">&#9670;&nbsp;</a></span>doFullLoopUnrolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * CompileTimeExpressionSimplifier::doFullLoopUnrolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_for.html">For</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLoopIterations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handles the full loop unrolling. This requires that the exact number of loop iterations is known. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The For-loop to be unrolled. </td></tr>
    <tr><td class="paramname">numLoopIterations</td><td>The number of iterations this For-loop would have been executed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new node if the given For-loop was replaced in the children vector of the For-loop's parent. </dd></dl>

</div>
</div>
<a id="a9b89277cae83880dab22a9065be943e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b89277cae83880dab22a9065be943e5">&#9670;&nbsp;</a></span>doPartialLoopUnrolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * CompileTimeExpressionSimplifier::doPartialLoopUnrolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_for.html">For</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handles the partial loop unrolling to enable batching of the loop's body statements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The For-loop to be unrolled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new node if the given For-loop was replaced in the children vector of the For-loop's parent. </dd></dl>

</div>
</div>
<a id="ac1d0d37c2122a173af72f610993067fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d0d37c2122a173af72f610993067fb">&#9670;&nbsp;</a></span>emitVariableAssignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_var_assignm.html">VarAssignm</a> * CompileTimeExpressionSimplifier::emitVariableAssignment </td>
          <td>(</td>
          <td class="paramtype">VariableValuesMapType::iterator&#160;</td>
          <td class="paramname"><em>variableToEmit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="class_var_assignm.html">VarAssignm</a> statement of the variable that the given iterator (variableToEmit) is pointing to. The method ensures that there exists a variable declaration statement (<a class="el" href="class_var_decl.html">VarDecl</a>) in the scope where this variable was originally declared. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableToEmit</td><td>The variable to be emitted, i.e., for that a variable assignment statement should be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A variable assignment statement for the given variable (variableToEmit). </dd></dl>

</div>
</div>
<a id="aed7b243ee43a5e5025b3d99304f6a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7b243ee43a5e5025b3d99304f6a256">&#9670;&nbsp;</a></span>emitVariableDeclaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::emitVariableDeclaration </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::pair&lt; std::string, <a class="el" href="class_scope.html">Scope</a> * &gt;, <a class="el" href="struct_variable_value.html">VariableValue</a> * &gt;::iterator&#160;</td>
          <td class="paramname"><em>variableToEmit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="class_var_decl.html">VarDecl</a> statements of the variable that the given iterator (variableToEmit) is pointing to. The variable declaration is emitted as the first statement in the scope where the variable was initially declared. The generated declaration statement is added to the emittedVariableDeclarations map to keep track of it. On contrary to emitVariableAssignment, this method automatically adds the statement to the AST instead of returning the generated statement. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableToEmit</td><td>The variable to be emitted, i.e., for that a variable declaration statement should be generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b591e8e43fe6290b5e56d02cb424cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b591e8e43fe6290b5e56d02cb424cfc">&#9670;&nbsp;</a></span>enqueueNodeForDeletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::enqueueNodeForDeletion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the given node for deletion. The node will be deleted after all nodes of the AST have been visited. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to be marked for deletion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9070fa0325013412b208f4fc2aa5d552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9070fa0325013412b208f4fc2aa5d552">&#9670;&nbsp;</a></span>evaluateNodeRecursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt; CompileTimeExpressionSimplifier::evaluateNodeRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt;&#160;</td>
          <td class="paramname"><em>valuesOfVariables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluates a subtree, i.e., a node and all of its children by using the <a class="el" href="class_evaluation_visitor.html">EvaluationVisitor</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The subtree's root node to be evaluated. </td></tr>
    <tr><td class="paramname">valuesOfVariables</td><td>The variable values required to evaluate this subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The evaluation's result as a vector of <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> pointers. <a class="el" href="class_if.html">If</a> the subtree does not include a <a class="el" href="class_return.html">Return</a> statement, then the result vector should always have one element only. </dd></dl>

</div>
</div>
<a id="a3671d8c8f8c8b61885c9ddea9b0af639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3671d8c8f8c8b61885c9ddea9b0af639">&#9670;&nbsp;</a></span>generateIfDependentValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> * CompileTimeExpressionSimplifier::generateIfDependentValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>trueValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>falseValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper method to transform an <a class="el" href="class_if.html">If</a> statement into a dependent assignment, for example: if (condition) { x = trueValue; } else { x = falseValue; } is converted into x = condition*trueValue + (1-b)*falseValue. This method takes the required parts of this expression, the condition, the value that should be assigned in case that the condition evaluates to True (trueValue) or to False (falseValue). It then generates and returns the following expression: condition*trueValue + (1-b)*falseValue. The method also considers the case where trueValue and/or falseValue are null and appropriately removes the irrelevant subtree from the resulting expression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition the assignment depends on, e.g., the condition of the <a class="el" href="class_if.html">If</a> statement. </td></tr>
    <tr><td class="paramname">trueValue</td><td>The value to be used for the case that the condition evaluates to True. </td></tr>
    <tr><td class="paramname">falseValue</td><td>The value to be used for the case that the condition evaluates to False. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An arithmetic expression of the form condition*trueValue + (1-b)*falseValue. </dd></dl>

</div>
</div>
<a id="ad032b5b9af518c40bcfc7c4d3e8cc64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad032b5b9af518c40bcfc7c4d3e8cc64c">&#9670;&nbsp;</a></span>getChangedVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableValuesMapType CompileTimeExpressionSimplifier::getChangedVariables </td>
          <td>(</td>
          <td class="paramtype">VariableValuesMapType&#160;</td>
          <td class="paramname"><em>variableValuesBeforeVisitingNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper method that takes a copy of the variableValues map that was created before visiting a node and determines the changes made by visiting the node. The changes recognized are newly declared variables (added variables) and variables whose value changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableValuesBeforeVisitingNode</td><td>A copy of the variable values map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The changes between the map variableValuesBeforeVisitingNode and the current variableValues map. </dd></dl>

</div>
</div>
<a id="a9558c06534da5a09d8022c031dd982b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9558c06534da5a09d8022c031dd982b6">&#9670;&nbsp;</a></span>getClonedVariableValuesMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableValuesMapType CompileTimeExpressionSimplifier::getClonedVariableValuesMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a clone of the variableValues map. As the map consists of <a class="el" href="struct_variable_value.html">VariableValue</a> pointers, each of the <a class="el" href="struct_variable_value.html">VariableValue</a> objects pointed to needs to be copied. </p><dl class="section return"><dt>Returns</dt><dd>A copy of the VariableValues map. </dd></dl>

</div>
</div>
<a id="ac8b4da6ae653865e6ceed19d1936a0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b4da6ae653865e6ceed19d1936a0de">&#9670;&nbsp;</a></span>getKnownValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> * CompileTimeExpressionSimplifier::getKnownValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value of the given node that is either the node itself if the node is an subtype of <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> or the known value (<a class="el" href="class_abstract_expr.html">AbstractExpr</a>) stored previously in the variableValues map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node for which the value should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>exception if the node does not have a known value. Must be checked before using the hasKnownValue method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node's value as <a class="el" href="class_abstract_expr.html">AbstractExpr</a>. </dd></dl>

</div>
</div>
<a id="aff0fda043df118abeeb41e1fd4dd5c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0fda043df118abeeb41e1fd4dd5c6c">&#9670;&nbsp;</a></span>getTransformedVariableMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> * &gt; CompileTimeExpressionSimplifier::getTransformedVariableMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes the variableValues map and creates a new map containing a copy of all <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> values. This map can then be passed to the <a class="el" href="class_evaluation_visitor.html">EvaluationVisitor</a> to evaluate a given subtree. The original variableValues map, however, contains AbstractExprs of non-evaluable variables too, for example, x=y+7 where y is a function parameter. </p><dl class="section return"><dt>Returns</dt><dd>A map of (variable identifier, variable value) pairs where variable values are AbstractLiterals. </dd></dl>

</div>
</div>
<a id="a29db4fa6087db8db78ef531a094ca08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29db4fa6087db8db78ef531a094ca08b">&#9670;&nbsp;</a></span>getVariableEntryDeclaredInThisOrOuterScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableValuesMapType::iterator CompileTimeExpressionSimplifier::getVariableEntryDeclaredInThisOrOuterScope </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>variableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator to the variable entry in variableValues that has the given variable identifier (variableName) and is closest from the current scope (curScope). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableName</td><td>The variable identifiers whose variableValues entry should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the variableValues entry pointing to the variable whose declaratin is closest to the current scope. </dd></dl>

</div>
</div>
<a id="a19863cb6e257e4b309a65ae08450bb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19863cb6e257e4b309a65ae08450bb47">&#9670;&nbsp;</a></span>getVariableValueDeclaredInThisOrOuterScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> * CompileTimeExpressionSimplifier::getVariableValueDeclaredInThisOrOuterScope </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>variableName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current value of the variable identified by the given variableName. <a class="el" href="class_if.html">If</a> there are multiple declarations within different scopes, returns the declaration that is closest to curScope. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableName</td><td>The variable identifiers whose value should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_abstract_expr.html">AbstractExpr</a> pointer of the variable's current value. </dd></dl>

</div>
</div>
<a id="a5778548f24ce6d174050436c95287a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5778548f24ce6d174050436c95287a8f">&#9670;&nbsp;</a></span>handleForLoopUnrolling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_node.html">AbstractNode</a> * CompileTimeExpressionSimplifier::handleForLoopUnrolling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_for.html">For</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper method that is visited when a For-loop is found. This method in turn calls itself on the next "deeper" nested loop before continuing to fully or partially unrolling the loop. The first call to this method is invoked by the For-loop's visit method, any deeper nested calls directly call this handleForLoopUnrolling method. This allows to determine when processing the outermost For-loop is finished such that expressions can be revisited and deleted if required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The For-loop to be unrolled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the node if the given For-loop was replaced in the children vector of the For-loop's parent. </dd></dl>

</div>
</div>
<a id="acc6478142374de1a96867c6f89720ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6478142374de1a96867c6f89720ca3">&#9670;&nbsp;</a></span>hasKnownValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CompileTimeExpressionSimplifier::hasKnownValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the given node has a known value. A value is considered as known if</p><ul>
<li>the node itself is any subtype of an <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> this includes matrices of a concrete type (e.g., <a class="el" href="class_literal_int.html">LiteralInt</a> containing Matrix&lt;int&gt;) but not matrices containing AbstractExprs,</li>
<li>the node is a <a class="el" href="class_variable.html">Variable</a> and the referred value is known</li>
<li>or the node's value is not relevant anymore as it is marked for deletion. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node for which the presence of a value should be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the node's value is known, otherwise False. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a75588a958c194e9e426d543c2d1ce3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75588a958c194e9e426d543c2d1ce3f1">&#9670;&nbsp;</a></span>isQueuedForDeletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CompileTimeExpressionSimplifier::isQueuedForDeletion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the given node is queued for deletion. Deletion will be carried out at the end of the traversal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to be checked for deletion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this node is enqueued for deletion, otherwise False. </dd></dl>

</div>
</div>
<a id="af05945043cd0586ea24f2b9d4f8d8ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05945043cd0586ea24f2b9d4f8d8ff8">&#9670;&nbsp;</a></span>markNodeAsRemovable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::markNodeAsRemovable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_node.html">AbstractNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks a node as a candidate for deletion. The node's first ancestor that is a statement has to decide whether its children that are marked to be removed can be deleted or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node for which the evaluation result should be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ca5d9e165382fd86bd831360078ad57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca5d9e165382fd86bd831360078ad57">&#9670;&nbsp;</a></span>removeVarsWrittenAndReadFromVariableValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::pair&lt; std::string, <a class="el" href="class_scope.html">Scope</a> * &gt; &gt; CompileTimeExpressionSimplifier::removeVarsWrittenAndReadFromVariableValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>blockStmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all variables from variableValues that are written in any statement of the given block (blockStmt). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockStmt</td><td>The <a class="el" href="class_block.html">Block</a> consisting of the statements that are analyzed for variable writes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of pairs consisting of (variable identifier, variable declaration scope) of those variables that are identified to be written to within in the block's statements. </dd></dl>

</div>
</div>
<a id="a90268685049aacbf542f3fce396e738b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90268685049aacbf542f3fce396e738b">&#9670;&nbsp;</a></span>setMatrixVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::setMatrixVariableValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variableIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>matrixElementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a new value matrixElementValue to the position indicated by (row, column) in matrix referred by variableIdentifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableIdentifier</td><td>A reference to a matrix, i.e., any subtype of an <a class="el" href="class_abstract_literal.html">AbstractLiteral</a>. </td></tr>
    <tr><td class="paramname">row</td><td>The row index where the new value should be written to. </td></tr>
    <tr><td class="paramname">column</td><td>The column index where the new value should be written to. </td></tr>
    <tr><td class="paramname">matrixElementValue</td><td>The matrix value that should be written to the index given as (row, column). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00cb29d4b29bff0ade58a6633d8f7b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cb29d4b29bff0ade58a6633d8f7b71">&#9670;&nbsp;</a></span>setVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::setVariableValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variableIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_expr.html">AbstractExpr</a> *&#160;</td>
          <td class="paramname"><em>valueAnyLiteralOrAbstractExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method sets the value (valueAnyLiteralOrAbstractExpr) of a variable named as given by the variableIdentifier parameter. It keeps the scope of the already existing entry in the variableValues map and only changes the variable's value. The suitable entry for the given variable identifier is determined starting by the current scope (Visitor::curScope) and then visiting the outer scope, the next outer scope, et cetera. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableIdentifier</td><td>The variable identifier ("name" of the variable). </td></tr>
    <tr><td class="paramname">valueAnyLiteralOrAbstractExpr</td><td>The variable's value. This can be any kind of <a class="el" href="class_abstract_literal.html">AbstractLiteral</a> or <a class="el" href="class_abstract_expr.html">AbstractExpr</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6133d91be73fe723689392bdade892e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6133d91be73fe723689392bdade892e4">&#9670;&nbsp;</a></span>simplifyLogicalExpr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CompileTimeExpressionSimplifier::simplifyLogicalExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_operator_expr.html">OperatorExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes an <a class="el" href="class_operator_expr.html">OperatorExpr</a> consisting of a logical operator (i.e., AND, XOR, OR) and applies the Boolean laws to simplify the expression. <a class="el" href="class_for.html">For</a> example, the expression &lt;anything&gt; AND False always evaluates to False, hence we can replace this <a class="el" href="class_operator_expr.html">OperatorExpr</a> by the boolean value (<a class="el" href="class_literal_bool.html">LiteralBool</a>) False. Other considered rules include:</p><ul>
<li>&lt;anything&gt; AND False ⟹ False</li>
<li>&lt;anything&gt; AND True ⟹ &lt;anything&gt;</li>
<li>&lt;anything&gt; OR True ⟹ True</li>
<li>&lt;anything&gt; OR False ⟹ &lt;anything&gt;</li>
<li>&lt;anything&gt; XOR False ⟹ &lt;anything&gt;</li>
<li>&lt;anything&gt; XOR True ⟹ !&lt;anything&gt; [not implemented yet] where &lt;anything&gt; denotes an arbitrary logical expression of the same logical operator. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>The <a class="el" href="class_operator_expr.html">OperatorExpr</a> that should be simplified using Boolean laws. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3a966eb79247b99396ad31efe46e0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a966eb79247b99396ad31efe46e0c3">&#9670;&nbsp;</a></span>nodesQueuedForDeletion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;<a class="el" href="class_abstract_node.html">AbstractNode</a> *&gt; CompileTimeExpressionSimplifier::nodesQueuedForDeletion</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains pointer to those nodes for which full or partial evaluation could be performed and hence can be deleted at the end of this simplification traversal. <a class="el" href="class_for.html">For</a> example, the arithmetic expression represented by <a class="el" href="class_arithmetic_expr.html">ArithmeticExpr</a>( <a class="el" href="class_literal_int.html">LiteralInt(12)</a>, OpSymb::add, <a class="el" href="class_literal_int.html">LiteralInt(42)</a> ) will be evaluated to 12+42=54. The node <a class="el" href="class_arithmetic_expr.html">ArithmeticExpr</a> (and all of its children) will be deleted and replaced by a new node <a class="el" href="class_literal_int.html">LiteralInt(54)</a>. </p>

</div>
</div>
<a id="ac742ab530e2090d4154ea717efcfee1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac742ab530e2090d4154ea717efcfee1b">&#9670;&nbsp;</a></span>removableNodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;<a class="el" href="class_abstract_node.html">AbstractNode</a> *&gt; CompileTimeExpressionSimplifier::removableNodes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contains all nodes that can potentially be removed. The decision of a node's removal is to be made by its parent statement. <a class="el" href="class_if.html">If</a> this decision is made (i.e., at the end of processing the statement), the node must be deleted from removableNodes.</p><ul>
<li>AbstractNode*: A reference to the removable node. </li>
</ul>

</div>
</div>
<a id="a2cb269763a2f078201f628f8aa36055f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb269763a2f078201f628f8aa36055f">&#9670;&nbsp;</a></span>replaceVariablesByValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CompileTimeExpressionSimplifier::replaceVariablesByValues {true}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A flag that indicates whether variables should be replaced by their known value. The value can be a concrete value (i.e., subtype of <a class="el" href="class_abstract_literal.html">AbstractLiteral</a>) or a symbolic value containing unknown variables (e.g., x = y+4). This is not to be confused with evaluation of expressions where yet unknown expressions are computed. </p>

</div>
</div>
<a id="a2614357b812cde2f183025eebe936460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2614357b812cde2f183025eebe936460">&#9670;&nbsp;</a></span>variableValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VariableValuesMapType CompileTimeExpressionSimplifier::variableValues</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the latest value of a variable while traversing through the AST. Entries in this map consist of a key (pair) that is made of a variable identifier (first) and the scope where the variable was declared in (second). The entry of the variableValues map is the current value of the associated variable. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/visitor/<a class="el" href="_compile_time_expression_simplifier_8h_source.html">CompileTimeExpressionSimplifier.h</a></li>
<li>src/visitor/CompileTimeExpressionSimplifier.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
