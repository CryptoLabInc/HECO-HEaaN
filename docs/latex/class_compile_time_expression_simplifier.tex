\hypertarget{class_compile_time_expression_simplifier}{}\doxysection{Compile\+Time\+Expression\+Simplifier Class Reference}
\label{class_compile_time_expression_simplifier}\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
Inheritance diagram for Compile\+Time\+Expression\+Simplifier\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_compile_time_expression_simplifier}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_abstract_statement}{Abstract\+Statement}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_arithmetic_expr}{Arithmetic\+Expr}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_abstract_matrix}{Abstract\+Matrix}} \&elem) override
\item 
void \mbox{\hyperlink{group__visit_ga10e310077a51158ba211d39a0c4cb8de}{visit}} (\mbox{\hyperlink{class_ast}{Ast}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_block}{Block}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_call}{Call}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_call_external}{Call\+External}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_datatype}{Datatype}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_function}{Function}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_function_parameter}{Function\+Parameter}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_for}{For}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_matrix_element_ref}{Matrix\+Element\+Ref}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_get_matrix_size}{Get\+Matrix\+Size}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_if}{If}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_literal_bool}{Literal\+Bool}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_literal_float}{Literal\+Float}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_literal_int}{Literal\+Int}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_literal_string}{Literal\+String}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_logical_expr}{Logical\+Expr}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_operator}{Operator}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_parameter_list}{Parameter\+List}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_return}{Return}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_unary_expr}{Unary\+Expr}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_var_assignm}{Var\+Assignm}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_var_decl}{Var\+Decl}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_variable}{Variable}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_while}{While}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_rotate}{Rotate}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_matrix_assignm}{Matrix\+Assignm}} \&elem) override
\item 
void {\bfseries visit} (\mbox{\hyperlink{class_transpose}{Transpose}} \&elem) override
\item 
bool \mbox{\hyperlink{class_compile_time_expression_simplifier_acc6478142374de1a96867c6f89720ca3}{has\+Known\+Value}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_af05945043cd0586ea24f2b9d4f8d8ff8}{mark\+Node\+As\+Removable}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node)
\item 
\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_ac8b4da6ae653865e6ceed19d1936a0de}{get\+Known\+Value}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node)
\item 
std\+::vector$<$ \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a9070fa0325013412b208f4fc2aa5d552}{evaluate\+Node\+Recursive}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node, std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$ values\+Of\+Variables)
\item 
std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$ \mbox{\hyperlink{class_compile_time_expression_simplifier_aff0fda043df118abeeb41e1fd4dd5c6c}{get\+Transformed\+Variable\+Map}} ()
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_a1c200ac987ce33d137d1fc24c14a83a4}{clean\+Up\+After\+Statement\+Visited}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$statement, bool enqueue\+Statement\+For\+Deletion=false)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_a1f21eb6a481f3cdc6c18a807ec9bb481}{add\+Declared\+Variable}} (std\+::string var\+Identifier, \mbox{\hyperlink{class_datatype}{Datatype}} $\ast$d\+Type, \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$value)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_a00cb29d4b29bff0ade58a6633d8f7b71}{set\+Variable\+Value}} (const std\+::string \&variable\+Identifier, \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$value\+Any\+Literal\+Or\+Abstract\+Expr)
\item 
bool \mbox{\hyperlink{class_compile_time_expression_simplifier_a75588a958c194e9e426d543c2d1ce3f1}{is\+Queued\+For\+Deletion}} (const \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node)
\item 
Variable\+Values\+Map\+Type \mbox{\hyperlink{class_compile_time_expression_simplifier_ad032b5b9af518c40bcfc7c4d3e8cc64c}{get\+Changed\+Variables}} (Variable\+Values\+Map\+Type variable\+Values\+Before\+Visiting\+Node)
\item 
std\+::set$<$ std\+::pair$<$ std\+::string, \mbox{\hyperlink{class_scope}{Scope}} $\ast$ $>$ $>$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a7ca5d9e165382fd86bd831360078ad57}{remove\+Vars\+Written\+And\+Read\+From\+Variable\+Values}} (\mbox{\hyperlink{class_block}{Block}} \&block\+Stmt)
\item 
\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a19863cb6e257e4b309a65ae08450bb47}{get\+Variable\+Value\+Declared\+In\+This\+Or\+Outer\+Scope}} (std\+::string variable\+Name)
\item 
Variable\+Values\+Map\+Type\+::iterator \mbox{\hyperlink{class_compile_time_expression_simplifier_a29db4fa6087db8db78ef531a094ca08b}{get\+Variable\+Entry\+Declared\+In\+This\+Or\+Outer\+Scope}} (std\+::string variable\+Name)
\item 
\mbox{\hyperlink{class_var_assignm}{Var\+Assignm}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_ac1d0d37c2122a173af72f610993067fb}{emit\+Variable\+Assignment}} (Variable\+Values\+Map\+Type\+::iterator variable\+To\+Emit)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_aed7b243ee43a5e5025b3d99304f6a256}{emit\+Variable\+Declaration}} (std\+::map$<$ std\+::pair$<$ std\+::string, \mbox{\hyperlink{class_scope}{Scope}} $\ast$ $>$, \mbox{\hyperlink{struct_variable_value}{Variable\+Value}} $\ast$ $>$\+::iterator variable\+To\+Emit)
\item 
Variable\+Values\+Map\+Type \mbox{\hyperlink{class_compile_time_expression_simplifier_a9558c06534da5a09d8022c031dd982b6}{get\+Cloned\+Variable\+Values\+Map}} ()
\item 
int \mbox{\hyperlink{class_compile_time_expression_simplifier_adac313617166dfcfa7e150a417975f4c}{determine\+Num\+Loop\+Iterations}} (\mbox{\hyperlink{class_for}{For}} \&elem)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_a8b591e8e43fe6290b5e56d02cb424cfc}{enqueue\+Node\+For\+Deletion}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$node)
\item 
void \mbox{\hyperlink{class_compile_time_expression_simplifier_a90268685049aacbf542f3fce396e738b}{set\+Matrix\+Variable\+Value}} (const std\+::string \&variable\+Identifier, int row, int column, \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$matrix\+Element\+Value)
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a5778548f24ce6d174050436c95287a8f}{handle\+For\+Loop\+Unrolling}} (\mbox{\hyperlink{class_for}{For}} \&elem)
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_af06897ae2ff2176c1f964014ca5b2c76}{do\+Full\+Loop\+Unrolling}} (\mbox{\hyperlink{class_for}{For}} \&elem, int num\+Loop\+Iterations)
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a9b89277cae83880dab22a9065be943e5}{do\+Partial\+Loop\+Unrolling}} (\mbox{\hyperlink{class_for}{For}} \&elem)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ \mbox{\hyperlink{class_compile_time_expression_simplifier_a3671d8c8f8c8b61885c9ddea9b0af639}{generate\+If\+Dependent\+Value}} (\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$condition, \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$true\+Value, \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$false\+Value)
\item 
static void \mbox{\hyperlink{class_compile_time_expression_simplifier_a6133d91be73fe723689392bdade892e4}{simplify\+Logical\+Expr}} (\mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} \&elem)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::unordered\+\_\+set$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{class_compile_time_expression_simplifier_ac742ab530e2090d4154ea717efcfee1b}{removable\+Nodes}}
\item 
Variable\+Values\+Map\+Type \mbox{\hyperlink{class_compile_time_expression_simplifier_a2614357b812cde2f183025eebe936460}{variable\+Values}}
\item 
std\+::deque$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{class_compile_time_expression_simplifier_ac3a966eb79247b99396ad31efe46e0c3}{nodes\+Queued\+For\+Deletion}}
\item 
bool \mbox{\hyperlink{class_compile_time_expression_simplifier_a2cb269763a2f078201f628f8aa36055f}{replace\+Variables\+By\+Values}} \{true\}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a1f21eb6a481f3cdc6c18a807ec9bb481}\label{class_compile_time_expression_simplifier_a1f21eb6a481f3cdc6c18a807ec9bb481}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!addDeclaredVariable@{addDeclaredVariable}}
\index{addDeclaredVariable@{addDeclaredVariable}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{addDeclaredVariable()}{addDeclaredVariable()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::add\+Declared\+Variable (\begin{DoxyParamCaption}\item[{std\+::string}]{var\+Identifier,  }\item[{\mbox{\hyperlink{class_datatype}{Datatype}} $\ast$}]{d\+Type,  }\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{value }\end{DoxyParamCaption})}

Saves information about a declared variable. Must include the variable\textquotesingle{}s identifier, the variable\textquotesingle{}s datatype, and optionally also an initializer (or nullptr otherwise). The method assumes that it is called from the variable\textquotesingle{}s declaration scope, hence saves Visitor\+::cur\+Scope as the variable\textquotesingle{}s declaration scope. 
\begin{DoxyParams}{Parameters}
{\em var\+Identifier} & The identifier of the declared variable. \\
\hline
{\em d\+Type} & The variable\textquotesingle{}s datatype. \\
\hline
{\em value} & The variable\textquotesingle{}s value, i.\+e., initializer. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a1c200ac987ce33d137d1fc24c14a83a4}\label{class_compile_time_expression_simplifier_a1c200ac987ce33d137d1fc24c14a83a4}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!cleanUpAfterStatementVisited@{cleanUpAfterStatementVisited}}
\index{cleanUpAfterStatementVisited@{cleanUpAfterStatementVisited}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{cleanUpAfterStatementVisited()}{cleanUpAfterStatementVisited()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::clean\+Up\+After\+Statement\+Visited (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{statement,  }\item[{bool}]{enqueue\+Statement\+For\+Deletion = {\ttfamily false} }\end{DoxyParamCaption})}

This method must be called at the end of the visit(...) of each statement. The method makes sure that the binary expression accumulator is reset and if specified by enqueue\+Statement\+For\+Deletion=True, also marks the given statement for deletion. 
\begin{DoxyParams}{Parameters}
{\em statement} & The statement for which visit(...) was executed. \\
\hline
{\em enqueue\+Statement\+For\+Deletion} & True if this statement should be marked for deletion, otherwise False (default). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_adac313617166dfcfa7e150a417975f4c}\label{class_compile_time_expression_simplifier_adac313617166dfcfa7e150a417975f4c}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!determineNumLoopIterations@{determineNumLoopIterations}}
\index{determineNumLoopIterations@{determineNumLoopIterations}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{determineNumLoopIterations()}{determineNumLoopIterations()}}
{\footnotesize\ttfamily int Compile\+Time\+Expression\+Simplifier\+::determine\+Num\+Loop\+Iterations (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_for}{For}} \&}]{elem }\end{DoxyParamCaption})}

A helper method that simulates the execution of the given For-\/loop to determine the number of iterations the loop would be executed. \mbox{\hyperlink{class_if}{If}} variable values involved in the loop\textquotesingle{}s condition are unknown, the method returns -\/1. Global data structures (e.\+g., variable\+Values or nodes\+Queued\+For\+Deletion) are restored to their state before calling this method. 
\begin{DoxyParams}{Parameters}
{\em elem} & The For-\/loop for that the number of loop iterations should be determined. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of iterations or -\/1 if not all variables required to simulate the loop\textquotesingle{}s execution are known. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_af06897ae2ff2176c1f964014ca5b2c76}\label{class_compile_time_expression_simplifier_af06897ae2ff2176c1f964014ca5b2c76}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!doFullLoopUnrolling@{doFullLoopUnrolling}}
\index{doFullLoopUnrolling@{doFullLoopUnrolling}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{doFullLoopUnrolling()}{doFullLoopUnrolling()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::do\+Full\+Loop\+Unrolling (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_for}{For}} \&}]{elem,  }\item[{int}]{num\+Loop\+Iterations }\end{DoxyParamCaption})}

Handles the full loop unrolling. This requires that the exact number of loop iterations is known. 
\begin{DoxyParams}{Parameters}
{\em elem} & The For-\/loop to be unrolled. \\
\hline
{\em num\+Loop\+Iterations} & The number of iterations this For-\/loop would have been executed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the new node if the given For-\/loop was replaced in the children vector of the For-\/loop\textquotesingle{}s parent. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a9b89277cae83880dab22a9065be943e5}\label{class_compile_time_expression_simplifier_a9b89277cae83880dab22a9065be943e5}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!doPartialLoopUnrolling@{doPartialLoopUnrolling}}
\index{doPartialLoopUnrolling@{doPartialLoopUnrolling}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{doPartialLoopUnrolling()}{doPartialLoopUnrolling()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::do\+Partial\+Loop\+Unrolling (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_for}{For}} \&}]{elem }\end{DoxyParamCaption})}

Handles the partial loop unrolling to enable batching of the loop\textquotesingle{}s body statements. 
\begin{DoxyParams}{Parameters}
{\em elem} & The For-\/loop to be unrolled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the new node if the given For-\/loop was replaced in the children vector of the For-\/loop\textquotesingle{}s parent. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_ac1d0d37c2122a173af72f610993067fb}\label{class_compile_time_expression_simplifier_ac1d0d37c2122a173af72f610993067fb}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!emitVariableAssignment@{emitVariableAssignment}}
\index{emitVariableAssignment@{emitVariableAssignment}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{emitVariableAssignment()}{emitVariableAssignment()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_var_assignm}{Var\+Assignm}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::emit\+Variable\+Assignment (\begin{DoxyParamCaption}\item[{Variable\+Values\+Map\+Type\+::iterator}]{variable\+To\+Emit }\end{DoxyParamCaption})}

Creates a new \mbox{\hyperlink{class_var_assignm}{Var\+Assignm}} statement of the variable that the given iterator (variable\+To\+Emit) is pointing to. The method ensures that there exists a variable declaration statement (\mbox{\hyperlink{class_var_decl}{Var\+Decl}}) in the scope where this variable was originally declared. 
\begin{DoxyParams}{Parameters}
{\em variable\+To\+Emit} & The variable to be emitted, i.\+e., for that a variable assignment statement should be generated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A variable assignment statement for the given variable (variable\+To\+Emit). 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_aed7b243ee43a5e5025b3d99304f6a256}\label{class_compile_time_expression_simplifier_aed7b243ee43a5e5025b3d99304f6a256}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!emitVariableDeclaration@{emitVariableDeclaration}}
\index{emitVariableDeclaration@{emitVariableDeclaration}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{emitVariableDeclaration()}{emitVariableDeclaration()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::emit\+Variable\+Declaration (\begin{DoxyParamCaption}\item[{std\+::map$<$ std\+::pair$<$ std\+::string, \mbox{\hyperlink{class_scope}{Scope}} $\ast$ $>$, \mbox{\hyperlink{struct_variable_value}{Variable\+Value}} $\ast$ $>$\+::iterator}]{variable\+To\+Emit }\end{DoxyParamCaption})}

Creates a new \mbox{\hyperlink{class_var_decl}{Var\+Decl}} statements of the variable that the given iterator (variable\+To\+Emit) is pointing to. The variable declaration is emitted as the first statement in the scope where the variable was initially declared. The generated declaration statement is added to the emitted\+Variable\+Declarations map to keep track of it. On contrary to emit\+Variable\+Assignment, this method automatically adds the statement to the A\+ST instead of returning the generated statement. 
\begin{DoxyParams}{Parameters}
{\em variable\+To\+Emit} & The variable to be emitted, i.\+e., for that a variable declaration statement should be generated. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a8b591e8e43fe6290b5e56d02cb424cfc}\label{class_compile_time_expression_simplifier_a8b591e8e43fe6290b5e56d02cb424cfc}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!enqueueNodeForDeletion@{enqueueNodeForDeletion}}
\index{enqueueNodeForDeletion@{enqueueNodeForDeletion}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{enqueueNodeForDeletion()}{enqueueNodeForDeletion()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::enqueue\+Node\+For\+Deletion (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node }\end{DoxyParamCaption})}

Marks the given node for deletion. The node will be deleted after all nodes of the A\+ST have been visited. 
\begin{DoxyParams}{Parameters}
{\em node} & The node to be marked for deletion. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a9070fa0325013412b208f4fc2aa5d552}\label{class_compile_time_expression_simplifier_a9070fa0325013412b208f4fc2aa5d552}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!evaluateNodeRecursive@{evaluateNodeRecursive}}
\index{evaluateNodeRecursive@{evaluateNodeRecursive}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{evaluateNodeRecursive()}{evaluateNodeRecursive()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$ Compile\+Time\+Expression\+Simplifier\+::evaluate\+Node\+Recursive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node,  }\item[{std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$}]{values\+Of\+Variables }\end{DoxyParamCaption})}

Evaluates a subtree, i.\+e., a node and all of its children by using the \mbox{\hyperlink{class_evaluation_visitor}{Evaluation\+Visitor}}. 
\begin{DoxyParams}{Parameters}
{\em node} & The subtree\textquotesingle{}s root node to be evaluated. \\
\hline
{\em values\+Of\+Variables} & The variable values required to evaluate this subtree. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The evaluation\textquotesingle{}s result as a vector of \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} pointers. \mbox{\hyperlink{class_if}{If}} the subtree does not include a \mbox{\hyperlink{class_return}{Return}} statement, then the result vector should always have one element only. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a3671d8c8f8c8b61885c9ddea9b0af639}\label{class_compile_time_expression_simplifier_a3671d8c8f8c8b61885c9ddea9b0af639}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!generateIfDependentValue@{generateIfDependentValue}}
\index{generateIfDependentValue@{generateIfDependentValue}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{generateIfDependentValue()}{generateIfDependentValue()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::generate\+If\+Dependent\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{condition,  }\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{true\+Value,  }\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{false\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

A helper method to transform an \mbox{\hyperlink{class_if}{If}} statement into a dependent assignment, for example\+: if (condition) \{ x = true\+Value; \} else \{ x = false\+Value; \} is converted into x = condition$\ast$true\+Value + (1-\/b)$\ast$false\+Value. This method takes the required parts of this expression, the condition, the value that should be assigned in case that the condition evaluates to True (true\+Value) or to False (false\+Value). It then generates and returns the following expression\+: condition$\ast$true\+Value + (1-\/b)$\ast$false\+Value. The method also considers the case where true\+Value and/or false\+Value are null and appropriately removes the irrelevant subtree from the resulting expression. 
\begin{DoxyParams}{Parameters}
{\em condition} & The condition the assignment depends on, e.\+g., the condition of the \mbox{\hyperlink{class_if}{If}} statement. \\
\hline
{\em true\+Value} & The value to be used for the case that the condition evaluates to True. \\
\hline
{\em false\+Value} & The value to be used for the case that the condition evaluates to False. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An arithmetic expression of the form condition$\ast$true\+Value + (1-\/b)$\ast$false\+Value. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_ad032b5b9af518c40bcfc7c4d3e8cc64c}\label{class_compile_time_expression_simplifier_ad032b5b9af518c40bcfc7c4d3e8cc64c}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getChangedVariables@{getChangedVariables}}
\index{getChangedVariables@{getChangedVariables}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getChangedVariables()}{getChangedVariables()}}
{\footnotesize\ttfamily Variable\+Values\+Map\+Type Compile\+Time\+Expression\+Simplifier\+::get\+Changed\+Variables (\begin{DoxyParamCaption}\item[{Variable\+Values\+Map\+Type}]{variable\+Values\+Before\+Visiting\+Node }\end{DoxyParamCaption})}

A helper method that takes a copy of the variable\+Values map that was created before visiting a node and determines the changes made by visiting the node. The changes recognized are newly declared variables (added variables) and variables whose value changed. 
\begin{DoxyParams}{Parameters}
{\em variable\+Values\+Before\+Visiting\+Node} & A copy of the variable values map. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The changes between the map variable\+Values\+Before\+Visiting\+Node and the current variable\+Values map. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a9558c06534da5a09d8022c031dd982b6}\label{class_compile_time_expression_simplifier_a9558c06534da5a09d8022c031dd982b6}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getClonedVariableValuesMap@{getClonedVariableValuesMap}}
\index{getClonedVariableValuesMap@{getClonedVariableValuesMap}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getClonedVariableValuesMap()}{getClonedVariableValuesMap()}}
{\footnotesize\ttfamily Variable\+Values\+Map\+Type Compile\+Time\+Expression\+Simplifier\+::get\+Cloned\+Variable\+Values\+Map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Creates a clone of the variable\+Values map. As the map consists of \mbox{\hyperlink{struct_variable_value}{Variable\+Value}} pointers, each of the \mbox{\hyperlink{struct_variable_value}{Variable\+Value}} objects pointed to needs to be copied. \begin{DoxyReturn}{Returns}
A copy of the Variable\+Values map. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_ac8b4da6ae653865e6ceed19d1936a0de}\label{class_compile_time_expression_simplifier_ac8b4da6ae653865e6ceed19d1936a0de}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getKnownValue@{getKnownValue}}
\index{getKnownValue@{getKnownValue}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getKnownValue()}{getKnownValue()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::get\+Known\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node }\end{DoxyParamCaption})}

Returns the value of the given node that is either the node itself if the node is an subtype of \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} or the known value (\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}}) stored previously in the variable\+Values map. 
\begin{DoxyParams}{Parameters}
{\em node} & The node for which the value should be retrieved. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::invalid\+\_\+argument} & exception if the node does not have a known value. Must be checked before using the has\+Known\+Value method. \\
\hline
\end{DoxyExceptions}
\begin{DoxyReturn}{Returns}
The node\textquotesingle{}s value as \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_aff0fda043df118abeeb41e1fd4dd5c6c}\label{class_compile_time_expression_simplifier_aff0fda043df118abeeb41e1fd4dd5c6c}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getTransformedVariableMap@{getTransformedVariableMap}}
\index{getTransformedVariableMap@{getTransformedVariableMap}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getTransformedVariableMap()}{getTransformedVariableMap()}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$ std\+::string, \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} $\ast$ $>$ Compile\+Time\+Expression\+Simplifier\+::get\+Transformed\+Variable\+Map (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Takes the variable\+Values map and creates a new map containing a copy of all \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} values. This map can then be passed to the \mbox{\hyperlink{class_evaluation_visitor}{Evaluation\+Visitor}} to evaluate a given subtree. The original variable\+Values map, however, contains Abstract\+Exprs of non-\/evaluable variables too, for example, x=y+7 where y is a function parameter. \begin{DoxyReturn}{Returns}
A map of (variable identifier, variable value) pairs where variable values are Abstract\+Literals. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a29db4fa6087db8db78ef531a094ca08b}\label{class_compile_time_expression_simplifier_a29db4fa6087db8db78ef531a094ca08b}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getVariableEntryDeclaredInThisOrOuterScope@{getVariableEntryDeclaredInThisOrOuterScope}}
\index{getVariableEntryDeclaredInThisOrOuterScope@{getVariableEntryDeclaredInThisOrOuterScope}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getVariableEntryDeclaredInThisOrOuterScope()}{getVariableEntryDeclaredInThisOrOuterScope()}}
{\footnotesize\ttfamily Variable\+Values\+Map\+Type\+::iterator Compile\+Time\+Expression\+Simplifier\+::get\+Variable\+Entry\+Declared\+In\+This\+Or\+Outer\+Scope (\begin{DoxyParamCaption}\item[{std\+::string}]{variable\+Name }\end{DoxyParamCaption})}

Returns an iterator to the variable entry in variable\+Values that has the given variable identifier (variable\+Name) and is closest from the current scope (cur\+Scope). 
\begin{DoxyParams}{Parameters}
{\em variable\+Name} & The variable identifiers whose variable\+Values entry should be retrieved. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An iterator to the variable\+Values entry pointing to the variable whose declaratin is closest to the current scope. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a19863cb6e257e4b309a65ae08450bb47}\label{class_compile_time_expression_simplifier_a19863cb6e257e4b309a65ae08450bb47}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!getVariableValueDeclaredInThisOrOuterScope@{getVariableValueDeclaredInThisOrOuterScope}}
\index{getVariableValueDeclaredInThisOrOuterScope@{getVariableValueDeclaredInThisOrOuterScope}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{getVariableValueDeclaredInThisOrOuterScope()}{getVariableValueDeclaredInThisOrOuterScope()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::get\+Variable\+Value\+Declared\+In\+This\+Or\+Outer\+Scope (\begin{DoxyParamCaption}\item[{std\+::string}]{variable\+Name }\end{DoxyParamCaption})}

Returns the current value of the variable identified by the given variable\+Name. \mbox{\hyperlink{class_if}{If}} there are multiple declarations within different scopes, returns the declaration that is closest to cur\+Scope. 
\begin{DoxyParams}{Parameters}
{\em variable\+Name} & The variable identifiers whose value should be retrieved. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} pointer of the variable\textquotesingle{}s current value. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a5778548f24ce6d174050436c95287a8f}\label{class_compile_time_expression_simplifier_a5778548f24ce6d174050436c95287a8f}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!handleForLoopUnrolling@{handleForLoopUnrolling}}
\index{handleForLoopUnrolling@{handleForLoopUnrolling}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{handleForLoopUnrolling()}{handleForLoopUnrolling()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Compile\+Time\+Expression\+Simplifier\+::handle\+For\+Loop\+Unrolling (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_for}{For}} \&}]{elem }\end{DoxyParamCaption})}

A wrapper method that is visited when a For-\/loop is found. This method in turn calls itself on the next \char`\"{}deeper\char`\"{} nested loop before continuing to fully or partially unrolling the loop. The first call to this method is invoked by the For-\/loop\textquotesingle{}s visit method, any deeper nested calls directly call this handle\+For\+Loop\+Unrolling method. This allows to determine when processing the outermost For-\/loop is finished such that expressions can be revisited and deleted if required. 
\begin{DoxyParams}{Parameters}
{\em elem} & The For-\/loop to be unrolled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the node if the given For-\/loop was replaced in the children vector of the For-\/loop\textquotesingle{}s parent. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_acc6478142374de1a96867c6f89720ca3}\label{class_compile_time_expression_simplifier_acc6478142374de1a96867c6f89720ca3}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!hasKnownValue@{hasKnownValue}}
\index{hasKnownValue@{hasKnownValue}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{hasKnownValue()}{hasKnownValue()}}
{\footnotesize\ttfamily bool Compile\+Time\+Expression\+Simplifier\+::has\+Known\+Value (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node }\end{DoxyParamCaption})}

Checks whether the given node has a known value. A value is considered as known if
\begin{DoxyItemize}
\item the node itself is any subtype of an \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} this includes matrices of a concrete type (e.\+g., \mbox{\hyperlink{class_literal_int}{Literal\+Int}} containing Matrix$<$int$>$) but not matrices containing Abstract\+Exprs,
\item the node is a \mbox{\hyperlink{class_variable}{Variable}} and the referred value is known
\item or the node\textquotesingle{}s value is not relevant anymore as it is marked for deletion. 
\begin{DoxyParams}{Parameters}
{\em node} & The node for which the presence of a value should be determined. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the node\textquotesingle{}s value is known, otherwise False. 
\end{DoxyReturn}

\end{DoxyItemize}\mbox{\Hypertarget{class_compile_time_expression_simplifier_a75588a958c194e9e426d543c2d1ce3f1}\label{class_compile_time_expression_simplifier_a75588a958c194e9e426d543c2d1ce3f1}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!isQueuedForDeletion@{isQueuedForDeletion}}
\index{isQueuedForDeletion@{isQueuedForDeletion}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{isQueuedForDeletion()}{isQueuedForDeletion()}}
{\footnotesize\ttfamily bool Compile\+Time\+Expression\+Simplifier\+::is\+Queued\+For\+Deletion (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node }\end{DoxyParamCaption})}

Checks whether the given node is queued for deletion. Deletion will be carried out at the end of the traversal. 
\begin{DoxyParams}{Parameters}
{\em node} & The node to be checked for deletion. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if this node is enqueued for deletion, otherwise False. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_af05945043cd0586ea24f2b9d4f8d8ff8}\label{class_compile_time_expression_simplifier_af05945043cd0586ea24f2b9d4f8d8ff8}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!markNodeAsRemovable@{markNodeAsRemovable}}
\index{markNodeAsRemovable@{markNodeAsRemovable}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{markNodeAsRemovable()}{markNodeAsRemovable()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::mark\+Node\+As\+Removable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{node }\end{DoxyParamCaption})}

Marks a node as a candidate for deletion. The node\textquotesingle{}s first ancestor that is a statement has to decide whether its children that are marked to be removed can be deleted or not. 
\begin{DoxyParams}{Parameters}
{\em node} & The node for which the evaluation result should be stored. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a7ca5d9e165382fd86bd831360078ad57}\label{class_compile_time_expression_simplifier_a7ca5d9e165382fd86bd831360078ad57}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!removeVarsWrittenAndReadFromVariableValues@{removeVarsWrittenAndReadFromVariableValues}}
\index{removeVarsWrittenAndReadFromVariableValues@{removeVarsWrittenAndReadFromVariableValues}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{removeVarsWrittenAndReadFromVariableValues()}{removeVarsWrittenAndReadFromVariableValues()}}
{\footnotesize\ttfamily std\+::set$<$ std\+::pair$<$ std\+::string, \mbox{\hyperlink{class_scope}{Scope}} $\ast$ $>$ $>$ Compile\+Time\+Expression\+Simplifier\+::remove\+Vars\+Written\+And\+Read\+From\+Variable\+Values (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_block}{Block}} \&}]{block\+Stmt }\end{DoxyParamCaption})}

Removes all variables from variable\+Values that are written in any statement of the given block (block\+Stmt). 
\begin{DoxyParams}{Parameters}
{\em block\+Stmt} & The \mbox{\hyperlink{class_block}{Block}} consisting of the statements that are analyzed for variable writes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A list of pairs consisting of (variable identifier, variable declaration scope) of those variables that are identified to be written to within in the block\textquotesingle{}s statements. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a90268685049aacbf542f3fce396e738b}\label{class_compile_time_expression_simplifier_a90268685049aacbf542f3fce396e738b}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!setMatrixVariableValue@{setMatrixVariableValue}}
\index{setMatrixVariableValue@{setMatrixVariableValue}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{setMatrixVariableValue()}{setMatrixVariableValue()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::set\+Matrix\+Variable\+Value (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{variable\+Identifier,  }\item[{int}]{row,  }\item[{int}]{column,  }\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{matrix\+Element\+Value }\end{DoxyParamCaption})}

Sets a new value matrix\+Element\+Value to the position indicated by (row, column) in matrix referred by variable\+Identifier. 
\begin{DoxyParams}{Parameters}
{\em variable\+Identifier} & A reference to a matrix, i.\+e., any subtype of an \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}}. \\
\hline
{\em row} & The row index where the new value should be written to. \\
\hline
{\em column} & The column index where the new value should be written to. \\
\hline
{\em matrix\+Element\+Value} & The matrix value that should be written to the index given as (row, column). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a00cb29d4b29bff0ade58a6633d8f7b71}\label{class_compile_time_expression_simplifier_a00cb29d4b29bff0ade58a6633d8f7b71}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!setVariableValue@{setVariableValue}}
\index{setVariableValue@{setVariableValue}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{setVariableValue()}{setVariableValue()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::set\+Variable\+Value (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{variable\+Identifier,  }\item[{\mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}} $\ast$}]{value\+Any\+Literal\+Or\+Abstract\+Expr }\end{DoxyParamCaption})}

This method sets the value (value\+Any\+Literal\+Or\+Abstract\+Expr) of a variable named as given by the variable\+Identifier parameter. It keeps the scope of the already existing entry in the variable\+Values map and only changes the variable\textquotesingle{}s value. The suitable entry for the given variable identifier is determined starting by the current scope (Visitor\+::cur\+Scope) and then visiting the outer scope, the next outer scope, et cetera. 
\begin{DoxyParams}{Parameters}
{\em variable\+Identifier} & The variable identifier (\char`\"{}name\char`\"{} of the variable). \\
\hline
{\em value\+Any\+Literal\+Or\+Abstract\+Expr} & The variable\textquotesingle{}s value. This can be any kind of \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}} or \mbox{\hyperlink{class_abstract_expr}{Abstract\+Expr}}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_a6133d91be73fe723689392bdade892e4}\label{class_compile_time_expression_simplifier_a6133d91be73fe723689392bdade892e4}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!simplifyLogicalExpr@{simplifyLogicalExpr}}
\index{simplifyLogicalExpr@{simplifyLogicalExpr}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{simplifyLogicalExpr()}{simplifyLogicalExpr()}}
{\footnotesize\ttfamily void Compile\+Time\+Expression\+Simplifier\+::simplify\+Logical\+Expr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} \&}]{elem }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Takes an \mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} consisting of a logical operator (i.\+e., A\+ND, X\+OR, OR) and applies the Boolean laws to simplify the expression. \mbox{\hyperlink{class_for}{For}} example, the expression $<$anything$>$ A\+ND False always evaluates to False, hence we can replace this \mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} by the boolean value (\mbox{\hyperlink{class_literal_bool}{Literal\+Bool}}) False. Other considered rules include\+:
\begin{DoxyItemize}
\item $<$anything$>$ A\+ND False ⟹ False
\item $<$anything$>$ A\+ND True ⟹ $<$anything$>$
\item $<$anything$>$ OR True ⟹ True
\item $<$anything$>$ OR False ⟹ $<$anything$>$
\item $<$anything$>$ X\+OR False ⟹ $<$anything$>$
\item $<$anything$>$ X\+OR True ⟹ !$<$anything$>$ \mbox{[}not implemented yet\mbox{]} where $<$anything$>$ denotes an arbitrary logical expression of the same logical operator. 
\begin{DoxyParams}{Parameters}
{\em elem} & The \mbox{\hyperlink{class_operator_expr}{Operator\+Expr}} that should be simplified using Boolean laws. \\
\hline
\end{DoxyParams}

\end{DoxyItemize}

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_compile_time_expression_simplifier_ac3a966eb79247b99396ad31efe46e0c3}\label{class_compile_time_expression_simplifier_ac3a966eb79247b99396ad31efe46e0c3}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!nodesQueuedForDeletion@{nodesQueuedForDeletion}}
\index{nodesQueuedForDeletion@{nodesQueuedForDeletion}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{nodesQueuedForDeletion}{nodesQueuedForDeletion}}
{\footnotesize\ttfamily std\+::deque$<$\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$$>$ Compile\+Time\+Expression\+Simplifier\+::nodes\+Queued\+For\+Deletion}

Contains pointer to those nodes for which full or partial evaluation could be performed and hence can be deleted at the end of this simplification traversal. \mbox{\hyperlink{class_for}{For}} example, the arithmetic expression represented by \mbox{\hyperlink{class_arithmetic_expr}{Arithmetic\+Expr}}( \mbox{\hyperlink{class_literal_int}{Literal\+Int(12)}}, Op\+Symb\+::add, \mbox{\hyperlink{class_literal_int}{Literal\+Int(42)}} ) will be evaluated to 12+42=54. The node \mbox{\hyperlink{class_arithmetic_expr}{Arithmetic\+Expr}} (and all of its children) will be deleted and replaced by a new node \mbox{\hyperlink{class_literal_int}{Literal\+Int(54)}}. \mbox{\Hypertarget{class_compile_time_expression_simplifier_ac742ab530e2090d4154ea717efcfee1b}\label{class_compile_time_expression_simplifier_ac742ab530e2090d4154ea717efcfee1b}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!removableNodes@{removableNodes}}
\index{removableNodes@{removableNodes}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{removableNodes}{removableNodes}}
{\footnotesize\ttfamily std\+::unordered\+\_\+set$<$\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$$>$ Compile\+Time\+Expression\+Simplifier\+::removable\+Nodes}

Contains all nodes that can potentially be removed. The decision of a node\textquotesingle{}s removal is to be made by its parent statement. \mbox{\hyperlink{class_if}{If}} this decision is made (i.\+e., at the end of processing the statement), the node must be deleted from removable\+Nodes.
\begin{DoxyItemize}
\item Abstract\+Node$\ast$\+: A reference to the removable node. 
\end{DoxyItemize}\mbox{\Hypertarget{class_compile_time_expression_simplifier_a2cb269763a2f078201f628f8aa36055f}\label{class_compile_time_expression_simplifier_a2cb269763a2f078201f628f8aa36055f}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!replaceVariablesByValues@{replaceVariablesByValues}}
\index{replaceVariablesByValues@{replaceVariablesByValues}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{replaceVariablesByValues}{replaceVariablesByValues}}
{\footnotesize\ttfamily bool Compile\+Time\+Expression\+Simplifier\+::replace\+Variables\+By\+Values \{true\}}

A flag that indicates whether variables should be replaced by their known value. The value can be a concrete value (i.\+e., subtype of \mbox{\hyperlink{class_abstract_literal}{Abstract\+Literal}}) or a symbolic value containing unknown variables (e.\+g., x = y+4). This is not to be confused with evaluation of expressions where yet unknown expressions are computed. \mbox{\Hypertarget{class_compile_time_expression_simplifier_a2614357b812cde2f183025eebe936460}\label{class_compile_time_expression_simplifier_a2614357b812cde2f183025eebe936460}} 
\index{CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}!variableValues@{variableValues}}
\index{variableValues@{variableValues}!CompileTimeExpressionSimplifier@{CompileTimeExpressionSimplifier}}
\doxysubsubsection{\texorpdfstring{variableValues}{variableValues}}
{\footnotesize\ttfamily Variable\+Values\+Map\+Type Compile\+Time\+Expression\+Simplifier\+::variable\+Values}

Stores the latest value of a variable while traversing through the A\+ST. Entries in this map consist of a key (pair) that is made of a variable identifier (first) and the scope where the variable was declared in (second). The entry of the variable\+Values map is the current value of the associated variable. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/visitor/Compile\+Time\+Expression\+Simplifier.\+h\item 
src/visitor/Compile\+Time\+Expression\+Simplifier.\+cpp\end{DoxyCompactItemize}
