\hypertarget{group__parents}{}\doxysection{Methods for handling children}
\label{group__parents}\index{Methods for handling children@{Methods for handling children}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
virtual int \mbox{\hyperlink{group__parents_ga680a94e1a61857e94177a79e5d8588ab}{Abstract\+Node\+::get\+Max\+Number\+Children}} ()
\item 
const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \& \mbox{\hyperlink{group__parents_ga86ad6064145b23d0db6cda7a254d1816}{Abstract\+Node\+::get\+Children}} () const
\item 
std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{group__parents_ga067cfe2f95324c36cfe3c8ad49d910c3}{Abstract\+Node\+::get\+Children\+Non\+Null}} () const
\item 
std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{group__parents_ga3a0fc647d80e0a0638dc5212475ff1d1}{Abstract\+Node\+::get\+Descendants}} ()
\item 
void \mbox{\hyperlink{group__parents_gaee3455077d7c2f5fe876736bc530ef14}{Abstract\+Node\+::add\+Child}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$child, bool add\+Back\+Reference=true)
\item 
void \mbox{\hyperlink{group__parents_ga823a5670ee7b3b8d31bc8b89f912ae17}{Abstract\+Node\+::add\+Children}} (const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&children\+To\+Add, bool add\+Back\+Reference=true)
\item 
void \mbox{\hyperlink{group__parents_ga11f2ad9e5498aa36ec2fe2ea233916e1}{Abstract\+Node\+::add\+Children}} (const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&children\+To\+Add, bool add\+Back\+Reference, std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$\+::const\+\_\+iterator insert\+Position)
\item 
void \mbox{\hyperlink{group__parents_ga4417c5c9ab73b36f0131bbb8a77e9a1a}{Abstract\+Node\+::add\+Children}} (const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&children\+To\+Add, bool add\+Back\+Reference, \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$insert\+Before\+Node)
\item 
void \mbox{\hyperlink{group__parents_ga5bbb1dbb67989121ad80e9a31d013832}{Abstract\+Node\+::remove\+Child}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$child, bool remove\+Backreference=true)
\item 
\mbox{\Hypertarget{group__parents_ga38e132143550927544b1f66c5fc1b822}\label{group__parents_ga38e132143550927544b1f66c5fc1b822}} 
void \mbox{\hyperlink{group__parents_ga38e132143550927544b1f66c5fc1b822}{Abstract\+Node\+::remove\+Children}} ()
\begin{DoxyCompactList}\small\item\em Removes all children from this node. Note\+: Does not update the child\textquotesingle{}s parent. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{group__parents_ga0701ca5077f4c8e72bb23f47847cd32f}{Abstract\+Node\+::replace\+Child}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$original\+Child, \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$new\+Child)
\item 
void \mbox{\hyperlink{group__parents_gae0c88c4188fe630a98fae969655cba5f}{Abstract\+Node\+::replace\+Children}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$original\+Child, std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ new\+Children)
\item 
int \mbox{\hyperlink{group__parents_gae9f882f7d81802944993122b2b0284a5}{Abstract\+Node\+::count\+Children\+Non\+Null}} () const
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{group__parents_gacc240879d8ea5f8a17f2c6ad75d3a9dd}{Abstract\+Node\+::get\+Child\+At\+Index}} (int idx) const
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{group__parents_gac253d38475ffb2b9314cf2b7f1a4f9e4}{Abstract\+Node\+::get\+Child\+At\+Index}} (int idx, bool is\+Edge\+Direction\+Aware) const
\item 
const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \& \mbox{\hyperlink{group__parents_gaae475feb918ba7baa8ab48b08c3e0c45}{Abstract\+Node\+::get\+Parents}} () const
\item 
std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{group__parents_ga1b1b017cb18e69edb9e3fb4a83065ca9}{Abstract\+Node\+::get\+Parents\+Non\+Null}} () const
\item 
std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \mbox{\hyperlink{group__parents_gab9ae438cb3ceceb4cb76105e44f5c7e4}{Abstract\+Node\+::get\+Ancestors}} ()
\item 
void \mbox{\hyperlink{group__parents_ga84feb2d0b8fe0cd9ec70039a6147cc05}{Abstract\+Node\+::add\+Parent}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$parent\+To\+Add, bool add\+Backreference=true)
\item 
void \mbox{\hyperlink{group__parents_gafda8df2202074840856b30041648319d}{Abstract\+Node\+::remove\+Parent}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$parent\+To\+Be\+Removed, bool remove\+Backreference=true)
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{group__parents_ga50bfef862849ba2a11873ee120364e09}{Abstract\+Node\+::remove\+From\+Parents}} (bool remove\+Parent\+Backreference=true)
\item 
\mbox{\Hypertarget{group__parents_ga51f1af895f45e9031069ec361ceb6499}\label{group__parents_ga51f1af895f45e9031069ec361ceb6499}} 
void \mbox{\hyperlink{group__parents_ga51f1af895f45e9031069ec361ceb6499}{Abstract\+Node\+::remove\+Parents}} ()
\begin{DoxyCompactList}\small\item\em Removes all parents from this node. Note\+: Does not update the parent\textquotesingle{}s children. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__parents_gac58926eb9237736d0a3593bd96375754}{Abstract\+Node\+::has\+Parent}} (\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$parent\+Node)
\item 
\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ \mbox{\hyperlink{group__parents_ga3d7d6aa6042b9935b178696c95840906}{Abstract\+Node\+::get\+Only\+Parent}} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__parents_gaee3455077d7c2f5fe876736bc530ef14}\label{group__parents_gaee3455077d7c2f5fe876736bc530ef14}} 
\index{Methods for handling children@{Methods for handling children}!addChild@{addChild}}
\index{addChild@{addChild}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{addChild()}{addChild()}}
{\footnotesize\ttfamily void Abstract\+Node\+::add\+Child (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{child,  }\item[{bool}]{add\+Back\+Reference = {\ttfamily true} }\end{DoxyParamCaption})}

Adds a new child node to the node\textquotesingle{}s list of children. \mbox{\hyperlink{class_if}{If}} add\+Back\+Reference is True then also updates the child\textquotesingle{}s list of parent nodes. 
\begin{DoxyParams}{Parameters}
{\em child} & The node to be added as child. \\
\hline
{\em add\+Back\+Reference} & \mbox{\hyperlink{class_if}{If}} True, then adds this node as parent to the child node. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_ga4417c5c9ab73b36f0131bbb8a77e9a1a}\label{group__parents_ga4417c5c9ab73b36f0131bbb8a77e9a1a}} 
\index{Methods for handling children@{Methods for handling children}!addChildren@{addChildren}}
\index{addChildren@{addChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{addChildren()}{addChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void Abstract\+Node\+::add\+Children (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&}]{children\+To\+Add,  }\item[{bool}]{add\+Back\+Reference,  }\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{insert\+Before\+Node }\end{DoxyParamCaption})}

Adds multiple children to the node\textquotesingle{}s list of children at the position (or more precisely, before) indicated by the passed node of the children vector. \mbox{\hyperlink{class_if}{If}} add\+Back\+Reference is True then also updates the child\textquotesingle{}s list of parent nodes for each of the added children. 
\begin{DoxyParams}{Parameters}
{\em children\+To\+Add} & A vector of nodes to be added as children to this node. \\
\hline
{\em add\+Back\+Reference} & \mbox{\hyperlink{class_if}{If}} True, then adds this node as parent to each of the child nodes. \\
\hline
{\em insert\+Before\+Node} & The node (must be a children of this node) that is used to determine the insert position of the children to be added. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::runtime\+\_\+error} & if the given node (insert\+Before\+Node) could not be found. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{group__parents_ga11f2ad9e5498aa36ec2fe2ea233916e1}\label{group__parents_ga11f2ad9e5498aa36ec2fe2ea233916e1}} 
\index{Methods for handling children@{Methods for handling children}!addChildren@{addChildren}}
\index{addChildren@{addChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{addChildren()}{addChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void Abstract\+Node\+::add\+Children (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&}]{children\+To\+Add,  }\item[{bool}]{add\+Back\+Reference,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$\+::const\+\_\+iterator}]{insert\+Position }\end{DoxyParamCaption})}

Adds multiple children to the node\textquotesingle{}s list of children at the position (or more precisely, before) indicated by the passed insert\+Position iterator of the children vector. \mbox{\hyperlink{class_if}{If}} add\+Back\+Reference is True then also updates the child\textquotesingle{}s list of parent nodes for each of the added children. 
\begin{DoxyParams}{Parameters}
{\em children\+To\+Add} & A vector of nodes to be added as children to this node. \\
\hline
{\em add\+Back\+Reference} & \mbox{\hyperlink{class_if}{If}} True, then adds this node as parent to each of the child nodes. \\
\hline
{\em insert\+Position} & The position before which the new nodes should be added to. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_ga823a5670ee7b3b8d31bc8b89f912ae17}\label{group__parents_ga823a5670ee7b3b8d31bc8b89f912ae17}} 
\index{Methods for handling children@{Methods for handling children}!addChildren@{addChildren}}
\index{addChildren@{addChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{addChildren()}{addChildren()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void Abstract\+Node\+::add\+Children (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \&}]{children\+To\+Add,  }\item[{bool}]{add\+Back\+Reference = {\ttfamily true} }\end{DoxyParamCaption})}

Adds multiple children to the node\textquotesingle{}s list of children. \mbox{\hyperlink{class_if}{If}} add\+Back\+Reference is True then also updates the child\textquotesingle{}s list of parent nodes for each of the added children. 
\begin{DoxyParams}{Parameters}
{\em children\+To\+Add} & A vector of nodes to be added as children to this node. \\
\hline
{\em add\+Back\+Reference} & \mbox{\hyperlink{class_if}{If}} True, then adds this node as parent to each of the child nodes. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_ga84feb2d0b8fe0cd9ec70039a6147cc05}\label{group__parents_ga84feb2d0b8fe0cd9ec70039a6147cc05}} 
\index{Methods for handling children@{Methods for handling children}!addParent@{addParent}}
\index{addParent@{addParent}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{addParent()}{addParent()}}
{\footnotesize\ttfamily void Abstract\+Node\+::add\+Parent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{parent\+To\+Add,  }\item[{bool}]{add\+Backreference = {\ttfamily true} }\end{DoxyParamCaption})}

Adds a new parent to this node\textquotesingle{}s list of parents. 
\begin{DoxyParams}{Parameters}
{\em parent\+To\+Add} & The parent node to be added. \\
\hline
{\em add\+Backreference} & \mbox{\hyperlink{class_if}{If}} True, then also adds this node as child to the new parent node. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_gae9f882f7d81802944993122b2b0284a5}\label{group__parents_gae9f882f7d81802944993122b2b0284a5}} 
\index{Methods for handling children@{Methods for handling children}!countChildrenNonNull@{countChildrenNonNull}}
\index{countChildrenNonNull@{countChildrenNonNull}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{countChildrenNonNull()}{countChildrenNonNull()}}
{\footnotesize\ttfamily int Abstract\+Node\+::count\+Children\+Non\+Null (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns the number of children nodes that are not null (nullptr). \begin{DoxyReturn}{Returns}
An integer indicating the number of non-\/nullptr children nodes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_gab9ae438cb3ceceb4cb76105e44f5c7e4}\label{group__parents_gab9ae438cb3ceceb4cb76105e44f5c7e4}} 
\index{Methods for handling children@{Methods for handling children}!getAncestors@{getAncestors}}
\index{getAncestors@{getAncestors}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getAncestors()}{getAncestors()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ Abstract\+Node\+::get\+Ancestors (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns all the ancestor nodes of the current node, i.\+e., the ancestors of this node, the ancestors of the ancestors et cetera. \begin{DoxyReturn}{Returns}
A list of ancestor nodes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_gacc240879d8ea5f8a17f2c6ad75d3a9dd}\label{group__parents_gacc240879d8ea5f8a17f2c6ad75d3a9dd}} 
\index{Methods for handling children@{Methods for handling children}!getChildAtIndex@{getChildAtIndex}}
\index{getChildAtIndex@{getChildAtIndex}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getChildAtIndex()}{getChildAtIndex()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Abstract\+Node\+::get\+Child\+At\+Index (\begin{DoxyParamCaption}\item[{int}]{idx }\end{DoxyParamCaption}) const}

Returns the child at the given index. 
\begin{DoxyParams}{Parameters}
{\em idx} & The position of the children in the \mbox{\hyperlink{class_abstract_node_a71a667554f9ca17ad0d56cbe5b22cc7f}{Abstract\+Node\+::children}} vector. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The child at the given index of the children vector, or a nullptr if there is no child at this position. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_gac253d38475ffb2b9314cf2b7f1a4f9e4}\label{group__parents_gac253d38475ffb2b9314cf2b7f1a4f9e4}} 
\index{Methods for handling children@{Methods for handling children}!getChildAtIndex@{getChildAtIndex}}
\index{getChildAtIndex@{getChildAtIndex}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getChildAtIndex()}{getChildAtIndex()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Abstract\+Node\+::get\+Child\+At\+Index (\begin{DoxyParamCaption}\item[{int}]{idx,  }\item[{bool}]{is\+Edge\+Direction\+Aware }\end{DoxyParamCaption}) const}

This special variant of get\+Child\+At\+Index returns the n-\/th parent instead of n-\/th child if is\+Edge\+Direction\+Aware is passed and is true, and the current node has the property is\+Reversed set to True. 
\begin{DoxyParams}{Parameters}
{\em idx} & The position of the child to be retrieved. \\
\hline
{\em is\+Edge\+Direction\+Aware} & \mbox{\hyperlink{class_if}{If}} the node\textquotesingle{}s status of is\+Reversed should be considered. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A reference to the node at the specified index in the children or parent vector. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga86ad6064145b23d0db6cda7a254d1816}\label{group__parents_ga86ad6064145b23d0db6cda7a254d1816}} 
\index{Methods for handling children@{Methods for handling children}!getChildren@{getChildren}}
\index{getChildren@{getChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getChildren()}{getChildren()}}
{\footnotesize\ttfamily const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \& Abstract\+Node\+::get\+Children (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns a reference to the vector of children nodes. \begin{DoxyReturn}{Returns}
A reference to the vector of this node\textquotesingle{}s children. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga067cfe2f95324c36cfe3c8ad49d910c3}\label{group__parents_ga067cfe2f95324c36cfe3c8ad49d910c3}} 
\index{Methods for handling children@{Methods for handling children}!getChildrenNonNull@{getChildrenNonNull}}
\index{getChildrenNonNull@{getChildrenNonNull}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getChildrenNonNull()}{getChildrenNonNull()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ Abstract\+Node\+::get\+Children\+Non\+Null (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns a vector of pointers to children nodes but without those children that are nullptr. \begin{DoxyReturn}{Returns}
A vector of non-\/nullptr children. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga3a0fc647d80e0a0638dc5212475ff1d1}\label{group__parents_ga3a0fc647d80e0a0638dc5212475ff1d1}} 
\index{Methods for handling children@{Methods for handling children}!getDescendants@{getDescendants}}
\index{getDescendants@{getDescendants}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getDescendants()}{getDescendants()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ Abstract\+Node\+::get\+Descendants (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns all the descendants nodes of the current node, i.\+e., the children of the children and the children of their children et cetera. \begin{DoxyReturn}{Returns}
A list of descendant nodes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga680a94e1a61857e94177a79e5d8588ab}\label{group__parents_ga680a94e1a61857e94177a79e5d8588ab}} 
\index{Methods for handling children@{Methods for handling children}!getMaxNumberChildren@{getMaxNumberChildren}}
\index{getMaxNumberChildren@{getMaxNumberChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getMaxNumberChildren()}{getMaxNumberChildren()}}
{\footnotesize\ttfamily int Abstract\+Node\+::get\+Max\+Number\+Children (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Indicates the number of children that are allowed for a specific node. \mbox{\hyperlink{class_for}{For}} example, a arithmetic expression accepts exactly three attributes and hence also exactly three children\+: left operand, right operand, and operator. \mbox{\hyperlink{class_if}{If}} the node does not implement support for child/parent relationships, \mbox{\hyperlink{group__parents_ga680a94e1a61857e94177a79e5d8588ab}{get\+Max\+Number\+Children()}} return 0. \begin{DoxyReturn}{Returns}
An integer indicating the number of allowed children for a specific node. 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{class_matrix_aad64645935e83c12ccc6c5ab6356799b}{Matrix$<$ T $>$}}, \mbox{\hyperlink{class_var_decl_a85b3beede024be269e838dd59d7048c4}{Var\+Decl}}, \mbox{\hyperlink{class_function_a63d68e9b2b23b123d3fe3b13bea2abf4}{Function}}, \mbox{\hyperlink{class_var_assignm_a0b277c03e0c6ea841f518196df932979}{Var\+Assignm}}, \mbox{\hyperlink{class_return_a9909ac70f65299e43fd539f7421946ea}{Return}}, \mbox{\hyperlink{class_unary_expr_afd8eca2716eea050d27fa88aaf1b3c28}{Unary\+Expr}}, \mbox{\hyperlink{class_for_aefa82931cfb8a8f65a410cf40d5cc5b2}{For}}, \mbox{\hyperlink{class_matrix_element_ref_aa2299ff8c6829be40ce038e4d365b0c1}{Matrix\+Element\+Ref}}, \mbox{\hyperlink{class_call_af1208c8bce54b77e6cd96f0c670fb006}{Call}}, \mbox{\hyperlink{class_get_matrix_size_a57d6d55759054f561a4f9003880c6bb0}{Get\+Matrix\+Size}}, \mbox{\hyperlink{class_block_a676784c7009b472921f6480ac5c87e53}{Block}}, \mbox{\hyperlink{class_function_parameter_a771297240b13c61c8301a74ff6020e53}{Function\+Parameter}}, \mbox{\hyperlink{class_if_af6961afb9692aaeeb551ebd5e48763c6}{If}}, \mbox{\hyperlink{class_transpose_a58b225cd13307e6d2c8f8aa3bb605e50}{Transpose}}, \mbox{\hyperlink{class_while_a762228f25805bb25193ffa7acfd63571}{While}}, \mbox{\hyperlink{class_operator_expr_a3f6a361ca69eae2ba9ca38540790d505}{Operator\+Expr}}, \mbox{\hyperlink{class_rotate_a20f3d6d52c55098e08d682631aad4386}{Rotate}}, \mbox{\hyperlink{class_parameter_list_af22158ec28263ca2e62054d49ff41d29}{Parameter\+List}}, \mbox{\hyperlink{class_matrix_assignm_a5e88f81e7dc657bf3e1131d164782dab}{Matrix\+Assignm}}, and \mbox{\hyperlink{class_abstract_binary_expr_a597b7d18a6dbd4a2d76245873ff90627}{Abstract\+Binary\+Expr}}.

\mbox{\Hypertarget{group__parents_ga3d7d6aa6042b9935b178696c95840906}\label{group__parents_ga3d7d6aa6042b9935b178696c95840906}} 
\index{Methods for handling children@{Methods for handling children}!getOnlyParent@{getOnlyParent}}
\index{getOnlyParent@{getOnlyParent}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getOnlyParent()}{getOnlyParent()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Abstract\+Node\+::get\+Only\+Parent (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns a pointer to the only parent node. \mbox{\hyperlink{class_if}{If}} this node has more than one parent, then a std\+::logic\+\_\+exception is thrown. \begin{DoxyReturn}{Returns}
A pointer to the node\textquotesingle{}s only parent node. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_gaae475feb918ba7baa8ab48b08c3e0c45}\label{group__parents_gaae475feb918ba7baa8ab48b08c3e0c45}} 
\index{Methods for handling children@{Methods for handling children}!getParents@{getParents}}
\index{getParents@{getParents}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getParents()}{getParents()}}
{\footnotesize\ttfamily const std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ \& Abstract\+Node\+::get\+Parents (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns a reference to the vector of parent nodes. \begin{DoxyReturn}{Returns}
A reference to the vector of this node\textquotesingle{}s parents. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga1b1b017cb18e69edb9e3fb4a83065ca9}\label{group__parents_ga1b1b017cb18e69edb9e3fb4a83065ca9}} 
\index{Methods for handling children@{Methods for handling children}!getParentsNonNull@{getParentsNonNull}}
\index{getParentsNonNull@{getParentsNonNull}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{getParentsNonNull()}{getParentsNonNull()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$ Abstract\+Node\+::get\+Parents\+Non\+Null (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Returns a vector of pointers to parent nodes but without those parents that are nullptr. \begin{DoxyReturn}{Returns}
A vector of non-\/nullptr parent nodes. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_gac58926eb9237736d0a3593bd96375754}\label{group__parents_gac58926eb9237736d0a3593bd96375754}} 
\index{Methods for handling children@{Methods for handling children}!hasParent@{hasParent}}
\index{hasParent@{hasParent}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{hasParent()}{hasParent()}}
{\footnotesize\ttfamily bool Abstract\+Node\+::has\+Parent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{parent\+Node }\end{DoxyParamCaption})}

Checks whether this node has a certain parent (parent\+Node). 
\begin{DoxyParams}{Parameters}
{\em parent\+Node} & The node that is searched for in this node\textquotesingle{}s parent list. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if this node has the given parent\+Node as parent, otherwise returns False. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__parents_ga5bbb1dbb67989121ad80e9a31d013832}\label{group__parents_ga5bbb1dbb67989121ad80e9a31d013832}} 
\index{Methods for handling children@{Methods for handling children}!removeChild@{removeChild}}
\index{removeChild@{removeChild}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{removeChild()}{removeChild()}}
{\footnotesize\ttfamily void Abstract\+Node\+::remove\+Child (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{child,  }\item[{bool}]{remove\+Backreference = {\ttfamily true} }\end{DoxyParamCaption})}

Removes the given child from the list of children. \mbox{\hyperlink{class_if}{If}} \mbox{\hyperlink{group__parents_ga680a94e1a61857e94177a79e5d8588ab}{get\+Max\+Number\+Children()}} returns -\/1 (i.\+e., this node supports an inifinite number of children, then the respective child is simply deleted. In any other case, the child node is overwritten by -\/1 such that the order of other children is preserved. 
\begin{DoxyParams}{Parameters}
{\em child} & The child to be removed from this node\textquotesingle{}s children. \\
\hline
{\em remove\+Backreference} & \mbox{\hyperlink{class_if}{If}} True, then also removes this node from the children\textquotesingle{}s list of parent nodes. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_ga50bfef862849ba2a11873ee120364e09}\label{group__parents_ga50bfef862849ba2a11873ee120364e09}} 
\index{Methods for handling children@{Methods for handling children}!removeFromParents@{removeFromParents}}
\index{removeFromParents@{removeFromParents}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{removeFromParents()}{removeFromParents()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ Abstract\+Node\+::remove\+From\+Parents (\begin{DoxyParamCaption}\item[{bool}]{remove\+Parent\+Backreference = {\ttfamily true} }\end{DoxyParamCaption})}

Removes this node from its parent\textquotesingle{}s children list. \mbox{\hyperlink{class_if}{If}} remove\+Parent\+Backreference is True, then also removes the parents from this node\textquotesingle{}s parent list. 
\begin{DoxyParams}{Parameters}
{\em remove\+Parent\+Backreference} & Indicates whether to update this node\textquotesingle{}s parents list too. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_gafda8df2202074840856b30041648319d}\label{group__parents_gafda8df2202074840856b30041648319d}} 
\index{Methods for handling children@{Methods for handling children}!removeParent@{removeParent}}
\index{removeParent@{removeParent}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{removeParent()}{removeParent()}}
{\footnotesize\ttfamily void Abstract\+Node\+::remove\+Parent (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{parent\+To\+Be\+Removed,  }\item[{bool}]{remove\+Backreference = {\ttfamily true} }\end{DoxyParamCaption})}

Removes a certain parent from this node. 
\begin{DoxyParams}{Parameters}
{\em parent\+To\+Be\+Removed} & The node to be removed from this node\textquotesingle{}s parents. \\
\hline
{\em remove\+Backreference} & \mbox{\hyperlink{class_if}{If}} True, then also removes this node from the parent\+To\+Be\+Removed node\textquotesingle{}s children list. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__parents_ga0701ca5077f4c8e72bb23f47847cd32f}\label{group__parents_ga0701ca5077f4c8e72bb23f47847cd32f}} 
\index{Methods for handling children@{Methods for handling children}!replaceChild@{replaceChild}}
\index{replaceChild@{replaceChild}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{replaceChild()}{replaceChild()}}
{\footnotesize\ttfamily void Abstract\+Node\+::replace\+Child (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{original\+Child,  }\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{new\+Child }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Replaces a given child (original\+Child) of this node by a new node (new\+Child) and updates the child and parent references of both nodes. This method preserves the order of the children. 
\begin{DoxyParams}{Parameters}
{\em original\+Child} & The node to be replaced by new\+Child. \\
\hline
{\em new\+Child} & The node to be added at the same position as the original child was. \\
\hline
\end{DoxyParams}


Reimplemented in \mbox{\hyperlink{class_matrix_a477ed2fcc4b7915061f916d12393e01e}{Matrix$<$ T $>$}}, \mbox{\hyperlink{class_operator_expr_a762db37a274570b76006bb3fd5edfaee}{Operator\+Expr}}, and \mbox{\hyperlink{class_matrix_a171d7f0eb34c6643f6248095dd9c244a}{Matrix$<$ T $>$}}.

\mbox{\Hypertarget{group__parents_gae0c88c4188fe630a98fae969655cba5f}\label{group__parents_gae0c88c4188fe630a98fae969655cba5f}} 
\index{Methods for handling children@{Methods for handling children}!replaceChildren@{replaceChildren}}
\index{replaceChildren@{replaceChildren}!Methods for handling children@{Methods for handling children}}
\doxysubsubsection{\texorpdfstring{replaceChildren()}{replaceChildren()}}
{\footnotesize\ttfamily void Abstract\+Node\+::replace\+Children (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$}]{original\+Child,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_abstract_node}{Abstract\+Node}} $\ast$ $>$}]{new\+Children }\end{DoxyParamCaption})}

Replaces a given child (original\+Child) of this node by one or multiple new nodes (new\+Children) and updates the child and parent references of all affected nodes. This method preserves the order of the children when inserting the nodes. \mbox{\hyperlink{class_for}{For}} example\+: replace\+Children(\+C, \mbox{[}\+X, V, W\mbox{]}) on node with children = \mbox{[}a b C d e f\mbox{]} results in children = \mbox{[}a b X V W d e f\mbox{]}. 
\begin{DoxyParams}{Parameters}
{\em original\+Child} & The node to be replaced by new\+Children. \\
\hline
{\em new\+Children} & The children to be added at the original\+Child\textquotesingle{}s current position. \\
\hline
\end{DoxyParams}
