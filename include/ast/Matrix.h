#ifndef AST_OPTIMIZER_INCLUDE_AST_MATRIX_H_
#define AST_OPTIMIZER_INCLUDE_AST_MATRIX_H_

#include <vector>
#include <string>
#include <utility>
#include <iostream>
#include <sstream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

struct Dimension {
 public:
  int numRows, numColumns;

  Dimension(int numberOfRows, int numberOfColumns) : numRows(numberOfRows), numColumns(numberOfColumns) {}

  bool operator==(const Dimension &rhs) const {
    return numRows==rhs.numRows && numColumns==rhs.numColumns;
  }

  bool operator!=(const Dimension &rhs) const {
    return !(rhs==*this);
  }

  friend std::ostream &operator<<(std::ostream &os, const Dimension &dimension) {
    return os << "(" << dimension.numRows << "," << dimension.numColumns << ")";
  }

  bool isValidAccess(int row, int column) {
    // note that indices row/column start by 0
    return row < numRows && column < numColumns;
  }

  [[nodiscard]] bool hasDimension(int row, int column) const {
    return (*this)==Dimension(row, column);
  }
};

template<typename T>
class Matrix {
 public:
  // a matrix of row vectors
  std::vector<std::vector<T>> values;
  Dimension dim;

  Matrix(std::vector<std::vector<T>> inputMatrix)  /* NOLINT intentionally not explicit */
      : values(std::move(inputMatrix)), dim(Dimension(values.size(), values.at(0).size())) {
    int elementsPerRow = values.at(0).size();
    for (auto const &rowVector : values) {
      if (rowVector.size()!=elementsPerRow) {
        throw std::invalid_argument("Vector rows must all have the same number of elements!");
      }
    }
  }

  Matrix(T scalarValue) : dim({1, 1}) {  /* NOLINT intentionally not explicit */
    values = {{scalarValue}};
  }

  Matrix(Matrix<T> &other) : dim(Dimension(other.getDimensions().numRows, other.getDimensions().numColumns)) {
    values = other.values;
  }

  [[nodiscard]] bool isScalar() const {
    return dim.hasDimension(1, 1);
  }

  T getScalarValue() const {
    if (isScalar()) return values[0][0];
    throw std::logic_error("getScalarValue() not allowed on non-scalars!");
  }

  bool operator==(const Matrix &rhs) const {
    return values==rhs.values && dim==rhs.dim;
  }

  bool operator!=(const Matrix &rhs) const {
    return !(rhs==*this);
  }

  [[nodiscard]] json toJson() const {
    // return the scalar value if this is a (1,1) scalar matrix
    if (isScalar()) return json(getScalarValue());
    // if this is a matrix, return an array of arrays like [ [a00, b01, c02], [d10, e11, f12] ]
    json arrayOfArrays = json::array();
    for (int i = 0; i < values.size(); ++i) {
      arrayOfArrays.push_back(json(values[i]));
    }
    return arrayOfArrays;
  }

  // Returning std::vector<T>::reference is required here.
  // Credits to Mike Seymour from stackoverflow.com (https://stackoverflow.com/a/25770060/3017719).
  typename std::vector<T>::reference operator()(int row, int column) {
    if (!dim.isValidAccess(row, column)) {
      std::stringstream ss;
      ss << "Cannot access " << Dimension(row, column) << " because vector has dimensions " << getDimensions() << ".";
      throw std::invalid_argument(ss.str());
    }
    return values[row][column];
  }

  T getElement(int row, int column) {
    return values[row][column];
  }

  Dimension &getDimensions() {
    return dim;
  }

  void setValues(const std::vector<std::vector<T>> &newValues) {
    values = newValues;
  }

  std::string toString() {
    std::stringstream outputStr;
    // print boolean values as text (true, false) by default, otherwise the output (0,1) cannot be distinguished from
    // the output generated by integers
    outputStr << std::boolalpha;
    // return the scalar value as string
    if (isScalar()) {
      outputStr << getScalarValue();
      return outputStr.str();
    }
    // use MATLAB' matrice style for matrices, e.g., for a 3x3 matrix: [2 2 33; 3 1 1; 3 11 9]
    const std::string elementDelimiter = " ";
    const std::string rowDelimiter = "; ";
    outputStr << "[";
    for (int i = 0; i < values.size(); ++i) {
      for (int j = 0; j < values[i].size(); ++j) {
        outputStr << values[i][j];
        if (j!=values[i].size() - 1) outputStr << elementDelimiter;
      }
      if (i!=values.size() - 1) outputStr << rowDelimiter;
    }
    outputStr << "]" << std::endl;
    return outputStr.str();
  }

  bool allValuesEqual(T valueToBeComparedWith) {
    for (int i = 0; i < values.size(); ++i) {
      for (int j = 0; j < values[i].size(); ++j) {
        if (values[i][j]!=valueToBeComparedWith) return false;
      }
    }
    return true;
  }

  Matrix<T> *clone() {
    // call the Matrix's copy constructor
    auto *clonedMatrix = new Matrix<T>(*this);
    return clonedMatrix;
  }

};

#endif //AST_OPTIMIZER_INCLUDE_AST_MATRIX_H_
